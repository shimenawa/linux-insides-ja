
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Memblock Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="linux-mm-2.html" />
    
    
    <link rel="prev" href="./" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        <li class="header">Summary</li>
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../Booting/">
            
                <a href="../Booting/">
            
                    
                    Booting
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../Booting/linux-bootstrap-1.html">
            
                <a href="../Booting/linux-bootstrap-1.html">
            
                    
                    From bootloader to kernel
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../Booting/linux-bootstrap-2.html">
            
                <a href="../Booting/linux-bootstrap-2.html">
            
                    
                    First steps in the kernel setup code
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../Booting/linux-bootstrap-3.html">
            
                <a href="../Booting/linux-bootstrap-3.html">
            
                    
                    Video mode initialization and transition to protected mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="../Booting/linux-bootstrap-4.html">
            
                <a href="../Booting/linux-bootstrap-4.html">
            
                    
                    Transition to 64-bit mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="../Booting/linux-bootstrap-5.html">
            
                <a href="../Booting/linux-bootstrap-5.html">
            
                    
                    Kernel decompression
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../Initialization/">
            
                <a href="../Initialization/">
            
                    
                    Initialization
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../Initialization/linux-initialization-1.html">
            
                <a href="../Initialization/linux-initialization-1.html">
            
                    
                    First steps in the kernel
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../Initialization/linux-initialization-2.html">
            
                <a href="../Initialization/linux-initialization-2.html">
            
                    
                    Early interrupts handler
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../Initialization/linux-initialization-3.html">
            
                <a href="../Initialization/linux-initialization-3.html">
            
                    
                    Last preparations before the kernel entry point
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../Initialization/linux-initialization-4.html">
            
                <a href="../Initialization/linux-initialization-4.html">
            
                    
                    Kernel entry point
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="../Initialization/linux-initialization-5.html">
            
                <a href="../Initialization/linux-initialization-5.html">
            
                    
                    Continue architecture-specific boot-time initializations
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="../Initialization/linux-initialization-6.html">
            
                <a href="../Initialization/linux-initialization-6.html">
            
                    
                    Architecture-specific initializations, again...
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="../Initialization/linux-initialization-7.html">
            
                <a href="../Initialization/linux-initialization-7.html">
            
                    
                    End of the architecture-specific initializations, almost...
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="../Initialization/linux-initialization-8.html">
            
                <a href="../Initialization/linux-initialization-8.html">
            
                    
                    Scheduler initialization
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.9" data-path="../Initialization/linux-initialization-9.html">
            
                <a href="../Initialization/linux-initialization-9.html">
            
                    
                    RCU initialization
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.10" data-path="../Initialization/linux-initialization-10.html">
            
                <a href="../Initialization/linux-initialization-10.html">
            
                    
                    End of initialization
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../interrupts/">
            
                <a href="../interrupts/">
            
                    
                    Interrupts
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../interrupts/interrupts-1.html">
            
                <a href="../interrupts/interrupts-1.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../interrupts/interrupts-2.html">
            
                <a href="../interrupts/interrupts-2.html">
            
                    
                    Start to dive into interrupts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../interrupts/interrupts-3.html">
            
                <a href="../interrupts/interrupts-3.html">
            
                    
                    Interrupt handlers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="../interrupts/interrupts-4.html">
            
                <a href="../interrupts/interrupts-4.html">
            
                    
                    Initialization of non-early interrupt gates
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.5" data-path="../interrupts/interrupts-5.html">
            
                <a href="../interrupts/interrupts-5.html">
            
                    
                    Implementation of some exception handlers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.6" data-path="../interrupts/interrupts-6.html">
            
                <a href="../interrupts/interrupts-6.html">
            
                    
                    Handling Non-Maskable interrupts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.7" data-path="../interrupts/interrupts-7.html">
            
                <a href="../interrupts/interrupts-7.html">
            
                    
                    Dive into external hardware interrupts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.8" data-path="../interrupts/interrupts-8.html">
            
                <a href="../interrupts/interrupts-8.html">
            
                    
                    Initialization of external hardware interrupts structures
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.9" data-path="../interrupts/interrupts-9.html">
            
                <a href="../interrupts/interrupts-9.html">
            
                    
                    Softirq, Tasklets and Workqueues
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.10" data-path="../interrupts/interrupts-10.html">
            
                <a href="../interrupts/interrupts-10.html">
            
                    
                    Last part
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../SysCall/">
            
                <a href="../SysCall/">
            
                    
                    System calls
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../SysCall/syscall-1.html">
            
                <a href="../SysCall/syscall-1.html">
            
                    
                    Introduction to system calls
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="../SysCall/syscall-2.html">
            
                <a href="../SysCall/syscall-2.html">
            
                    
                    How the Linux kernel handles a system call
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="../SysCall/syscall-3.html">
            
                <a href="../SysCall/syscall-3.html">
            
                    
                    vsyscall and vDSO
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="../SysCall/syscall-4.html">
            
                <a href="../SysCall/syscall-4.html">
            
                    
                    How the Linux kernel runs a program
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.5" data-path="../SysCall/syscall-5.html">
            
                <a href="../SysCall/syscall-5.html">
            
                    
                    Implementation of the open system call
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../Timers/">
            
                <a href="../Timers/">
            
                    
                    Timers and time management
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../Timers/timers-1.html">
            
                <a href="../Timers/timers-1.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="../Timers/timers-2.html">
            
                <a href="../Timers/timers-2.html">
            
                    
                    Clocksource framework
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="../Timers/timers-3.html">
            
                <a href="../Timers/timers-3.html">
            
                    
                    The tick broadcast framework and dyntick
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="../Timers/timers-4.html">
            
                <a href="../Timers/timers-4.html">
            
                    
                    Introduction to timers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.5" data-path="../Timers/timers-5.html">
            
                <a href="../Timers/timers-5.html">
            
                    
                    Clockevents framework
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.6" data-path="../Timers/timers-6.html">
            
                <a href="../Timers/timers-6.html">
            
                    
                    x86 related clock sources
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.7" data-path="../Timers/timers-7.html">
            
                <a href="../Timers/timers-7.html">
            
                    
                    Time related system calls
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../SyncPrim/">
            
                <a href="../SyncPrim/">
            
                    
                    Synchronization primitives
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="../SyncPrim/sync-1.html">
            
                <a href="../SyncPrim/sync-1.html">
            
                    
                    Introduction to spinlocks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="../SyncPrim/sync-2.html">
            
                <a href="../SyncPrim/sync-2.html">
            
                    
                    Queued spinlocks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="../SyncPrim/sync-3.html">
            
                <a href="../SyncPrim/sync-3.html">
            
                    
                    Semaphores
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4" data-path="../SyncPrim/sync-4.html">
            
                <a href="../SyncPrim/sync-4.html">
            
                    
                    Mutex
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5" data-path="../SyncPrim/sync-5.html">
            
                <a href="../SyncPrim/sync-5.html">
            
                    
                    Reader/Writer semaphores
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.6" data-path="../SyncPrim/sync-6.html">
            
                <a href="../SyncPrim/sync-6.html">
            
                    
                    SeqLock
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.7" >
            
                <span>
            
                    
                    RCU
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.8" >
            
                <span>
            
                    
                    Lockdep
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="./">
            
                <a href="./">
            
                    
                    Memory management
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter active" data-level="1.8.1" data-path="linux-mm-1.html">
            
                <a href="linux-mm-1.html">
            
                    
                    Memblock
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="linux-mm-2.html">
            
                <a href="linux-mm-2.html">
            
                    
                    Fixmaps and ioremap
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="linux-mm-3.html">
            
                <a href="linux-mm-3.html">
            
                    
                    kmemcheck
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="../Cgroups/">
            
                <a href="../Cgroups/">
            
                    
                    Cgroups
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="../Cgroups/cgroups1.html">
            
                <a href="../Cgroups/cgroups1.html">
            
                    
                    Introduction to Control Groups
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" >
            
                <span>
            
                    
                    SMP
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="../Concepts/">
            
                <a href="../Concepts/">
            
                    
                    Concepts
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.11.1" data-path="../Concepts/per-cpu.html">
            
                <a href="../Concepts/per-cpu.html">
            
                    
                    Per-CPU variables
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.2" data-path="../Concepts/cpumask.html">
            
                <a href="../Concepts/cpumask.html">
            
                    
                    Cpumasks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.3" data-path="../Concepts/initcall.html">
            
                <a href="../Concepts/initcall.html">
            
                    
                    The initcall mechanism
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="../DataStructures/">
            
                <a href="../DataStructures/">
            
                    
                    Data Structures in the Linux Kernel
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.12.1" data-path="../DataStructures/dlist.html">
            
                <a href="../DataStructures/dlist.html">
            
                    
                    Doubly linked list
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.2" data-path="../DataStructures/radix-tree.html">
            
                <a href="../DataStructures/radix-tree.html">
            
                    
                    Radix tree
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.3" data-path="../DataStructures/bitmap.html">
            
                <a href="../DataStructures/bitmap.html">
            
                    
                    Bit arrays
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="../Theory/">
            
                <a href="../Theory/">
            
                    
                    Theory
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.13.1" data-path="../Theory/Paging.html">
            
                <a href="../Theory/Paging.html">
            
                    
                    Paging
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.2" data-path="../Theory/ELF.html">
            
                <a href="../Theory/ELF.html">
            
                    
                    Elf64
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.3" data-path="../Theory/asm.html">
            
                <a href="../Theory/asm.html">
            
                    
                    Inline assembly
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.4" >
            
                <span>
            
                    
                    CPUID
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.5" >
            
                <span>
            
                    
                    MSR
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.14" >
            
                <span>
            
                    
                    Initial ram disk
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.14.1" >
            
                <span>
            
                    
                    initrd
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="../Misc/">
            
                <a href="../Misc/">
            
                    
                    Misc
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.15.1" data-path="../Misc/how_kernel_compiled.html">
            
                <a href="../Misc/how_kernel_compiled.html">
            
                    
                    How the kernel is compiled
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.2" data-path="../Misc/linkers.html">
            
                <a href="../Misc/linkers.html">
            
                    
                    Linkers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.3" data-path="../Misc/contribute.html">
            
                <a href="../Misc/contribute.html">
            
                    
                    Linux kernel development
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.4" data-path="../Misc/program_startup.html">
            
                <a href="../Misc/program_startup.html">
            
                    
                    Program startup process in userspace
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.5" >
            
                <span>
            
                    
                    Write and Submit your first Linux kernel Patch
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.6" >
            
                <span>
            
                    
                    Data types in the kernel
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="../KernelStructures/">
            
                <a href="../KernelStructures/">
            
                    
                    KernelStructures
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.16.1" data-path="../KernelStructures/idt.html">
            
                <a href="../KernelStructures/idt.html">
            
                    
                    IDT
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.17" data-path="../LINKS.html">
            
                <a href="../LINKS.html">
            
                    
                    Useful links
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.18" data-path="../contributors.html">
            
                <a href="../contributors.html">
            
                    
                    Contributors
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Memblock</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="linux-kernel-memory-management-part-1">Linux kernel memory management Part 1.</h1>
<h2 id="introduction">Introduction</h2>
<p>Memory management is one of the most complex (and I think that it is the most complex) part of the operating system kernel. In the <a href="http://0xax.gitbooks.io/linux-insides/content/Initialization/linux-initialization-3.html" target="_blank">last preparations before the kernel entry point</a> part we stopped right before call of the <code>start_kernel</code> function. This function initializes all the kernel features (including architecture-dependent features) before the kernel runs the first <code>init</code> process. You may remember as we built early page tables, identity page tables and fixmap page tables in the boot time. No complicated memory management is working yet. When the <code>start_kernel</code> function is called we will see the transition to more complex data structures and techniques for memory management. For a good understanding of the initialization process in the linux kernel we need to have a clear understanding of these techniques. This chapter will provide an overview of the different parts of the linux kernel memory management framework and its API, starting from the <code>memblock</code>.</p>
<h2 id="memblock">Memblock</h2>
<p>Memblock is one of the methods of managing memory regions during the early bootstrap period while the usual kernel memory allocators are not up and
running yet. Previously it was called <code>Logical Memory Block</code>, but with the <a href="https://lkml.org/lkml/2010/7/13/68" target="_blank">patch</a> by Yinghai Lu, it was renamed to the <code>memblock</code>. As Linux kernel for <code>x86_64</code> architecture uses this method. We already met <code>memblock</code> in the <a href="http://0xax.gitbooks.io/linux-insides/content/Initialization/linux-initialization-3.html" target="_blank">Last preparations before the kernel entry point</a> part. And now it&apos;s time to get acquainted with it closer. We will see how it is implemented.</p>
<p>We will start to learn <code>memblock</code> from the data structures. Definitions of the all data structures can be found in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/memblock.h" target="_blank">include/linux/memblock.h</a> header file.</p>
<p>The first structure has the same name as this part and it is:</p>
<pre><code class="lang-C"><span class="hljs-keyword">struct</span> memblock {
         <span class="hljs-keyword">bool</span> bottom_up;
         <span class="hljs-keyword">phys_addr_t</span> current_limit;
         <span class="hljs-keyword">struct</span> memblock_type memory;   --&gt; <span class="hljs-built_in">array</span> of memblock_region
         <span class="hljs-keyword">struct</span> memblock_type reserved; --&gt; <span class="hljs-built_in">array</span> of memblock_region
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_HAVE_MEMBLOCK_PHYS_MAP</span>
         <span class="hljs-keyword">struct</span> memblock_type physmem;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
};
</code></pre>
<p>This structure contains five fields. First is <code>bottom_up</code> which allows allocating memory in bottom-up mode when it is <code>true</code>. Next field is <code>current_limit</code>. This field describes the limit size of the memory block. The next three fields describe the type of the memory block. It can be: reserved, memory and physical memory if the <code>CONFIG_HAVE_MEMBLOCK_PHYS_MAP</code> configuration option is enabled. Now we see yet another data structure - <code>memblock_type</code>. Let&apos;s look at its definition:</p>
<pre><code class="lang-C"><span class="hljs-keyword">struct</span> memblock_type {
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> cnt;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> max;
    <span class="hljs-keyword">phys_addr_t</span> total_size;
    <span class="hljs-keyword">struct</span> memblock_region *regions;
};
</code></pre>
<p>This structure provides information about the memory type. It contains fields which describe the number of memory regions which are inside the current memory block, the size of all memory regions, the size of the allocated array of the memory regions and pointer to the array of the <code>memblock_region</code> structures. <code>memblock_region</code> is a structure which describes a memory region. Its definition is:</p>
<pre><code class="lang-C"><span class="hljs-keyword">struct</span> memblock_region {
        <span class="hljs-keyword">phys_addr_t</span> base;
        <span class="hljs-keyword">phys_addr_t</span> size;
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags;
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_HAVE_MEMBLOCK_NODE_MAP</span>
        <span class="hljs-keyword">int</span> nid;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
};
</code></pre>
<p><code>memblock_region</code> provides the base address and size of the memory region as well as a flags field which can have the following values:</p>
<pre><code class="lang-C"><span class="hljs-keyword">enum</span> {
    MEMBLOCK_NONE    = <span class="hljs-number">0x0</span>,    <span class="hljs-comment">/* No special request */</span>
    MEMBLOCK_HOTPLUG    = <span class="hljs-number">0x1</span>,    <span class="hljs-comment">/* hotpluggable region */</span>
    MEMBLOCK_MIRROR    = <span class="hljs-number">0x2</span>,    <span class="hljs-comment">/* mirrored region */</span>
    MEMBLOCK_NOMAP    = <span class="hljs-number">0x4</span>,    <span class="hljs-comment">/* don&apos;t add to kernel direct mapping */</span>
};
</code></pre>
<p>Also <code>memblock_region</code> provides an integer field - <a href="http://en.wikipedia.org/wiki/Non-uniform_memory_access" target="_blank">numa</a> node selector, if the <code>CONFIG_HAVE_MEMBLOCK_NODE_MAP</code> configuration option is enabled.</p>
<p>Schematically we can imagine it as:</p>
<pre><code>+---------------------------+   +---------------------------+
|         memblock          |   |                           |
|  _______________________  |   |                           |
| |        memory         | |   |       Array of the        |
| |      memblock_type    |-|--&gt;|      memblock_region      |
| |_______________________| |   |                           |
|                           |   +---------------------------+
|  _______________________  |   +---------------------------+
| |       reserved        | |   |                           |
| |      memblock_type    |-|--&gt;|       Array of the        |
| |_______________________| |   |      memblock_region      |
|                           |   |                           |
+---------------------------+   +---------------------------+
</code></pre><p>These three structures: <code>memblock</code>, <code>memblock_type</code> and <code>memblock_region</code> are main in the <code>Memblock</code>. Now we know about it and can look at Memblock initialization process.</p>
<h2 id="memblock-initialization">Memblock initialization</h2>
<p>As all API of the <code>memblock</code> are described in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/memblock.h" target="_blank">include/linux/memblock.h</a> header file, all implementations of these functions are in the <a href="https://github.com/torvalds/linux/blob/master/mm/memblock.c" target="_blank">mm/memblock.c</a> source code file. Let&apos;s look at the top of the source code file and we will see the initialization of the <code>memblock</code> structure:</p>
<pre><code class="lang-C"><span class="hljs-keyword">struct</span> memblock memblock __initdata_memblock = {
    .memory.regions        = memblock_memory_init_regions,
    .memory.cnt            = <span class="hljs-number">1</span>,
    .memory.max            = INIT_MEMBLOCK_REGIONS,

    .reserved.regions    = memblock_reserved_init_regions,
    .reserved.cnt        = <span class="hljs-number">1</span>,
    .reserved.max        = INIT_MEMBLOCK_REGIONS,

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_HAVE_MEMBLOCK_PHYS_MAP</span>
    .physmem.regions    = memblock_physmem_init_regions,
    .physmem.cnt        = <span class="hljs-number">1</span>,
    .physmem.max        = INIT_PHYSMEM_REGIONS,
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
    .bottom_up            = <span class="hljs-literal">false</span>,
    .current_limit        = MEMBLOCK_ALLOC_ANYWHERE,
};
</code></pre>
<p>Here we can see initialization of the <code>memblock</code> structure which has the same name as structure - <code>memblock</code>. First of all note the <code>__initdata_memblock</code>. Definition of this macro looks like:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_ARCH_DISCARD_MEMBLOCK</span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __init_memblock __meminit</span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __initdata_memblock __meminitdata</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __init_memblock</span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __initdata_memblock</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
</code></pre>
<p>You can see that it depends on <code>CONFIG_ARCH_DISCARD_MEMBLOCK</code>. If this configuration option is enabled, memblock code will be put into the <code>.init</code> section and will be released after the kernel is booted up.</p>
<p>Next we can see the initialization of the <code>memblock_type memory</code>, <code>memblock_type reserved</code> and <code>memblock_type physmem</code> fields of the <code>memblock</code> structure. Here we are interested only in the <code>memblock_type.regions</code> initialization process. Note that every <code>memblock_type</code> field is initialized by and array of <code>memblock_region</code>s:</p>
<pre><code class="lang-C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> memblock_region memblock_memory_init_regions[INIT_MEMBLOCK_REGIONS] __initdata_memblock;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> memblock_region memblock_reserved_init_regions[INIT_MEMBLOCK_REGIONS] __initdata_memblock;
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_HAVE_MEMBLOCK_PHYS_MAP</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> memblock_region memblock_physmem_init_regions[INIT_PHYSMEM_REGIONS] __initdata_memblock;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
</code></pre>
<p>Every array contains 128 memory regions. We can see it in the <code>INIT_MEMBLOCK_REGIONS</code> macro definition:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INIT_MEMBLOCK_REGIONS   128</span>
</code></pre>
<p>Note that all arrays are also defined with the <code>__initdata_memblock</code> macro which we already saw in the <code>memblock</code> structure initialization (read above if you&apos;ve forgotten).</p>
<p>The last two fields describe that <code>bottom_up</code> allocation is disabled and the limit of the current Memblock is:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEMBLOCK_ALLOC_ANYWHERE (~(phys_addr_t)0)</span>
</code></pre>
<p>which is <code>0xffffffffffffffff</code>.</p>
<p>On this step the initialization of the <code>memblock</code> structure has been finished and we can have a look at the Memblock API.</p>
<h2 id="memblock-api">Memblock API</h2>
<p>Ok we have finished with the initialization of the <code>memblock</code> structure and now we can look at the Memblock API and its implementation. As I said above, the implementation of <code>memblock</code> is taking place fully in <a href="https://github.com/torvalds/linux/blob/master/mm/memblock.c" target="_blank">mm/memblock.c</a>. To understand how <code>memblock</code> works and how it is implemented, let&apos;s look at its usage first. There are a couple of <a href="http://lxr.free-electrons.com/ident?i=memblock" target="_blank">places</a> in the linux kernel where memblock is used. For example let&apos;s take <code>memblock_x86_fill</code> function from the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/e820.c#L1061" target="_blank">arch/x86/kernel/e820.c</a>. This function goes through the memory map provided by the <a href="http://en.wikipedia.org/wiki/E820" target="_blank">e820</a> and adds memory regions reserved by the kernel to the <code>memblock</code> with the <code>memblock_add</code> function. Since we have met the <code>memblock_add</code> function first, let&apos;s start from it.</p>
<p>This function takes a physical base address and the size of the memory region as arguments and add them to the <code>memblock</code>. The <code>memblock_add</code> function does not do anything special in its body, but just calls the:</p>
<pre><code class="lang-C">memblock_add_range(&amp;memblock.memory, base, size, MAX_NUMNODES, <span class="hljs-number">0</span>);
</code></pre>
<p>function. We pass the memory block type - <code>memory</code>, the physical base address and the size of the memory region, the maximum number of nodes which is 1 if <code>CONFIG_NODES_SHIFT</code> is not set in the configuration file or <code>1 &lt;&lt; CONFIG_NODES_SHIFT</code> if it is set, and the flags. The <code>memblock_add_range</code> function adds a new memory region to the memory block. It starts by checking the size of the given region and if it is zero it just returns. After this, <code>memblock_add_range</code> checks the existence of the memory regions in the <code>memblock</code> structure with the given <code>memblock_type</code>. If there are no memory regions, we just fill new a <code>memory_region</code> with the given values and return (we already saw the implementation of this in the <a href="http://0xax.gitbooks.io/linux-insides/content/Initialization/linux-initialization-3.html" target="_blank">First touch of the linux kernel memory manager framework</a>). If <code>memblock_type</code> is not empty, we start to add a new memory region to the <code>memblock</code> with the given <code>memblock_type</code>.</p>
<p>First of all we get the end of the memory region with the:</p>
<pre><code class="lang-C"><span class="hljs-keyword">phys_addr_t</span> end = base + memblock_cap_size(base, &amp;size);
</code></pre>
<p><code>memblock_cap_size</code> adjusts <code>size</code> that <code>base + size</code> will not overflow. Its implementation is pretty easy:</p>
<pre><code class="lang-C"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> phys_addr_t <span class="hljs-title">memblock_cap_size</span><span class="hljs-params">(phys_addr_t base, phys_addr_t *size)</span>
</span>{
    <span class="hljs-keyword">return</span> *size = min(*size, (<span class="hljs-keyword">phys_addr_t</span>)ULLONG_MAX - base);
}
</code></pre>
<p><code>memblock_cap_size</code> returns the new size which is the smallest value between the given size and <code>ULLONG_MAX - base</code>.</p>
<p>After that we have the end address of the new memory region, <code>memblock_add_range</code> checks for overlap and merge conditions with memory regions that have been added before. Insertion of the new memory region to the <code>memblock</code> consists of two steps:</p>
<ul>
<li>Adding of non-overlapping parts of the new memory area as separate regions;</li>
<li>Merging of all neighboring regions.</li>
</ul>
<p>We are going through all the already stored memory regions and checking for overlap with the new region:</p>
<pre><code class="lang-C">    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; type-&gt;cnt; i++) {
        <span class="hljs-keyword">struct</span> memblock_region *rgn = &amp;type-&gt;regions[i];
        <span class="hljs-keyword">phys_addr_t</span> rbase = rgn-&gt;base;
        <span class="hljs-keyword">phys_addr_t</span> rend = rbase + rgn-&gt;size;

        <span class="hljs-keyword">if</span> (rbase &gt;= end)
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">if</span> (rend &lt;= base)
            <span class="hljs-keyword">continue</span>;
        ...
        ...
        ...
    }
</code></pre>
<p>If the new memory region does not overlap with regions which are already stored in the <code>memblock</code>, insert this region into the memblock with and this is first step, we check if the new region can fit into the memory block and call <code>memblock_double_array</code> in another way:</p>
<pre><code class="lang-C"><span class="hljs-keyword">while</span> (type-&gt;cnt + nr_new &gt; type-&gt;max)
    <span class="hljs-keyword">if</span> (memblock_double_array(type, obase, size) &lt; <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> -ENOMEM;
    insert = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">goto</span> repeat;
</code></pre>
<p><code>memblock_double_array</code> doubles the size of the given regions array. Then we set <code>insert</code> to <code>true</code> and go to the <code>repeat</code> label. In the second step, starting from the <code>repeat</code> label we go through the same loop and insert the current memory region into the memory block with the <code>memblock_insert_region</code> function:</p>
<pre><code class="lang-C">    <span class="hljs-keyword">if</span> (base &lt; end) {
        nr_new++;
        <span class="hljs-keyword">if</span> (insert)
            memblock_insert_region(type, i, base, end - base,
                           nid, flags);
    }
</code></pre>
<p>Since we set <code>insert</code> to <code>true</code> in the first step, now <code>memblock_insert_region</code> will be called. <code>memblock_insert_region</code> has almost the same implementation that we saw when we inserted a new region to the empty <code>memblock_type</code> (see above). This function gets the last memory region:</p>
<pre><code class="lang-C"><span class="hljs-keyword">struct</span> memblock_region *rgn = &amp;type-&gt;regions[idx];
</code></pre>
<p>and copies the memory area with <code>memmove</code>:</p>
<pre><code class="lang-C">memmove(rgn + <span class="hljs-number">1</span>, rgn, (type-&gt;cnt - idx) * <span class="hljs-keyword">sizeof</span>(*rgn));
</code></pre>
<p>After this fills <code>memblock_region</code> fields of the new memory region base, size, etc. and increases size of the <code>memblock_type</code>. In the end of the execution, <code>memblock_add_range</code> calls <code>memblock_merge_regions</code> which merges neighboring compatible regions in the second step.</p>
<p>In the second case the new memory region can overlap already stored regions. For example we already have <code>region1</code> in the <code>memblock</code>:</p>
<pre><code>0                    0x1000
+-----------------------+
|                       |
|                       |
|        region1        |
|                       |
|                       |
+-----------------------+
</code></pre><p>And now we want to add <code>region2</code> to the <code>memblock</code> with the following base address and size:</p>
<pre><code>0x100                 0x2000
+-----------------------+
|                       |
|                       |
|        region2        |
|                       |
|                       |
+-----------------------+
</code></pre><p>In this case set the base address of the new memory region as the end address of the overlapped region with:</p>
<pre><code class="lang-C">base = min(rend, end);
</code></pre>
<p>So it will be <code>0x1000</code> in our case. And insert it as we did it already in the second step with:</p>
<pre><code>if (base &lt; end) {
    nr_new++;
    if (insert)
        memblock_insert_region(type, i, base, end - base, nid, flags);
}
</code></pre><p>In this case we insert <code>overlapping portion</code> (we insert only the higher portion, because the lower portion is already in the overlapped memory region), then the remaining portion and merge these portions with <code>memblock_merge_regions</code>. As I said above <code>memblock_merge_regions</code> function merges neighboring compatible regions. It goes through all memory regions from the given <code>memblock_type</code>, takes two neighboring memory regions - <code>type-&gt;regions[i]</code> and <code>type-&gt;regions[i + 1]</code> and checks that these regions have the same flags, belong to the same node and that the end address of the first regions is not equal to the base address of the second region:</p>
<pre><code class="lang-C"><span class="hljs-keyword">while</span> (i &lt; type-&gt;cnt - <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">struct</span> memblock_region *<span class="hljs-keyword">this</span> = &amp;type-&gt;regions[i];
    <span class="hljs-keyword">struct</span> memblock_region *next = &amp;type-&gt;regions[i + <span class="hljs-number">1</span>];
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;base + <span class="hljs-keyword">this</span>-&gt;size != next-&gt;base ||
        memblock_get_region_node(<span class="hljs-keyword">this</span>) !=
        memblock_get_region_node(next) ||
        <span class="hljs-keyword">this</span>-&gt;flags != next-&gt;flags) {
        BUG_ON(<span class="hljs-keyword">this</span>-&gt;base + <span class="hljs-keyword">this</span>-&gt;size &gt; next-&gt;base);
        i++;
        <span class="hljs-keyword">continue</span>;
    }
</code></pre>
<p>If none of these conditions are true, we update the size of the first region with the size of the next region:</p>
<pre><code class="lang-C"><span class="hljs-keyword">this</span>-&gt;size += next-&gt;size;
</code></pre>
<p>As we update the size of the first memory region with the size of the next memory region, we move all memory regions which are after the (<code>next</code>) memory region one index backwards with the <code>memmove</code> function:</p>
<pre><code class="lang-C">memmove(next, next + <span class="hljs-number">1</span>, (type-&gt;cnt - (i + <span class="hljs-number">2</span>)) * <span class="hljs-keyword">sizeof</span>(*next));
</code></pre>
<p>The <code>memmove</code> here moves all regions which are located after the <code>next</code> region to the base address of the <code>next</code> region. In the end we just decrease the count of the memory regions which belong to the <code>memblock_type</code>:</p>
<pre><code class="lang-C">type-&gt;cnt--;
</code></pre>
<p>After this we will get two memory regions merged into one:</p>
<pre><code>0                                             0x2000
+------------------------------------------------+
|                                                |
|                                                |
|                   region1                      |
|                                                |
|                                                |
+------------------------------------------------+
</code></pre><p>As we decreased counts of regions in a memblock with certain type, increased size of the <code>this</code> region and shifted all regions which are located after <code>next</code> region to its place.</p>
<p>That&apos;s all. This is the whole principle of the work of the <code>memblock_add_range</code> function.</p>
<p>There is also <code>memblock_reserve</code> function which does the same as <code>memblock_add</code>, but with one difference. It stores <code>memblock_type.reserved</code> in the memblock instead of <code>memblock_type.memory</code>.</p>
<p>Of course this is not the full API. Memblock provides APIs not only for adding <code>memory</code> and <code>reserved</code> memory regions, but also:</p>
<ul>
<li>memblock_remove - removes memory region from memblock;</li>
<li>memblock_find_in_range - finds free area in given range;</li>
<li>memblock_free - releases memory region in memblock;</li>
<li>for_each_mem_range - iterates through memblock areas.</li>
</ul>
<p>and many more....</p>
<h2 id="getting-info-about-memory-regions">Getting info about memory regions</h2>
<p>Memblock also provides an API for getting information about allocated memory regions in the <code>memblock</code>. It is split in two parts:</p>
<ul>
<li>get_allocated_memblock_memory_regions_info - getting info about memory regions;</li>
<li>get_allocated_memblock_reserved_regions_info - getting info about reserved regions.</li>
</ul>
<p>Implementation of these functions is easy. Let&apos;s look at <code>get_allocated_memblock_reserved_regions_info</code> for example:</p>
<pre><code class="lang-C"><span class="hljs-keyword">phys_addr_t</span> __<span class="hljs-function">init_memblock <span class="hljs-title">get_allocated_memblock_reserved_regions_info</span><span class="hljs-params">(
                    phys_addr_t *addr)</span>
</span>{
    <span class="hljs-keyword">if</span> (memblock.reserved.regions == memblock_reserved_init_regions)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    *addr = __pa(memblock.reserved.regions);

    <span class="hljs-keyword">return</span> PAGE_ALIGN(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> memblock_region) *
              memblock.reserved.max);
}
</code></pre>
<p>First of all this function checks that <code>memblock</code> contains reserved memory regions. If <code>memblock</code> does not contain reserved memory regions we just return zero. Otherwise we write the physical address of the reserved memory regions array to the given address and return aligned size of the allocated array. Note that there is <code>PAGE_ALIGN</code> macro used for align. Actually it depends on size of page:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PAGE_ALIGN(addr) ALIGN(addr, PAGE_SIZE)</span>
</code></pre>
<p>Implementation of the <code>get_allocated_memblock_memory_regions_info</code> function is the same. It has only one difference, <code>memblock_type.memory</code> used instead of <code>memblock_type.reserved</code>.</p>
<h2 id="memblock-debugging">Memblock debugging</h2>
<p>There are many calls to <code>memblock_dbg</code> in the memblock implementation. If you pass the <code>memblock=debug</code> option to the kernel command line, this function will be called. Actually <code>memblock_dbg</code> is just a macro which expands to <code>printk</code>:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> memblock_dbg(fmt, ...) \
         <span class="hljs-meta-keyword">if</span> (memblock_debug) printk(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__)</span>
</code></pre>
<p>For example you can see a call of this macro in the <code>memblock_reserve</code> function:</p>
<pre><code class="lang-C">memblock_dbg(<span class="hljs-string">&quot;memblock_reserve: [%#016llx-%#016llx] flags %#02lx %pF\n&quot;</span>,
             (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)base,
             (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)base + size - <span class="hljs-number">1</span>,
             flags, (<span class="hljs-keyword">void</span> *)_RET_IP_);
</code></pre>
<p>And you will see something like this:</p>
<p><img src="http://oi57.tinypic.com/1zoj589.jpg" alt="Memblock"></p>
<p>Memblock also has support in <a href="http://en.wikipedia.org/wiki/Debugfs" target="_blank">debugfs</a>. If you run the kernel on another architecture than <code>X86</code> you can access:</p>
<ul>
<li>/sys/kernel/debug/memblock/memory</li>
<li>/sys/kernel/debug/memblock/reserved</li>
<li>/sys/kernel/debug/memblock/physmem</li>
</ul>
<p>to get a dump of the <code>memblock</code> contents.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This is the end of the first part about linux kernel memory management. If you have questions or suggestions, ping me on twitter <a href="https://twitter.com/0xAX" target="_blank">0xAX</a>, drop me an <a href="anotherworldofworld@gmail.com">email</a> or just create an <a href="https://github.com/0xAX/linux-insides/issues/new" target="_blank">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me a PR to <a href="https://github.com/0xAX/linux-insides" target="_blank">linux-insides</a>.</strong></p>
<h2 id="links">Links</h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/E820" target="_blank">e820</a></li>
<li><a href="http://en.wikipedia.org/wiki/Non-uniform_memory_access" target="_blank">numa</a></li>
<li><a href="http://en.wikipedia.org/wiki/Debugfs" target="_blank">debugfs</a></li>
<li><a href="http://0xax.gitbooks.io/linux-insides/content/Initialization/linux-initialization-3.html" target="_blank">First touch of the linux kernel memory manager framework</a></li>
</ul>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="./" class="navigation navigation-prev " aria-label="Previous page: Memory management">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="linux-mm-2.html" class="navigation navigation-next " aria-label="Next page: Fixmaps and ioremap">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Memblock","level":"1.8.1","depth":2,"next":{"title":"Fixmaps and ioremap","level":"1.8.2","depth":2,"path":"mm/linux-mm-2.md","ref":"mm/linux-mm-2.md","articles":[]},"previous":{"title":"Memory management","level":"1.8","depth":1,"path":"mm/README.md","ref":"mm/README.md","articles":[{"title":"Memblock","level":"1.8.1","depth":2,"path":"mm/linux-mm-1.md","ref":"mm/linux-mm-1.md","articles":[]},{"title":"Fixmaps and ioremap","level":"1.8.2","depth":2,"path":"mm/linux-mm-2.md","ref":"mm/linux-mm-2.md","articles":[]},{"title":"kmemcheck","level":"1.8.3","depth":2,"path":"mm/linux-mm-3.md","ref":"mm/linux-mm-3.md","articles":[]}]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"mm/linux-mm-1.md","mtime":"2019-03-28T07:54:50.432Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2019-03-28T08:02:31.511Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

