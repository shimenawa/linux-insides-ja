
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Architecture-specific initializations, again... Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="linux-initialization-7.html" />
    
    
    <link rel="prev" href="linux-initialization-5.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        <li class="header">Summary</li>
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../Booting/">
            
                <a href="../Booting/">
            
                    
                    Booting
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../Booting/linux-bootstrap-1.html">
            
                <a href="../Booting/linux-bootstrap-1.html">
            
                    
                    From bootloader to kernel
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../Booting/linux-bootstrap-2.html">
            
                <a href="../Booting/linux-bootstrap-2.html">
            
                    
                    First steps in the kernel setup code
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../Booting/linux-bootstrap-3.html">
            
                <a href="../Booting/linux-bootstrap-3.html">
            
                    
                    Video mode initialization and transition to protected mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="../Booting/linux-bootstrap-4.html">
            
                <a href="../Booting/linux-bootstrap-4.html">
            
                    
                    Transition to 64-bit mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="../Booting/linux-bootstrap-5.html">
            
                <a href="../Booting/linux-bootstrap-5.html">
            
                    
                    Kernel decompression
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="./">
            
                <a href="./">
            
                    
                    Initialization
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="linux-initialization-1.html">
            
                <a href="linux-initialization-1.html">
            
                    
                    First steps in the kernel
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="linux-initialization-2.html">
            
                <a href="linux-initialization-2.html">
            
                    
                    Early interrupts handler
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="linux-initialization-3.html">
            
                <a href="linux-initialization-3.html">
            
                    
                    Last preparations before the kernel entry point
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="linux-initialization-4.html">
            
                <a href="linux-initialization-4.html">
            
                    
                    Kernel entry point
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="linux-initialization-5.html">
            
                <a href="linux-initialization-5.html">
            
                    
                    Continue architecture-specific boot-time initializations
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.3.6" data-path="linux-initialization-6.html">
            
                <a href="linux-initialization-6.html">
            
                    
                    Architecture-specific initializations, again...
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="linux-initialization-7.html">
            
                <a href="linux-initialization-7.html">
            
                    
                    End of the architecture-specific initializations, almost...
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="linux-initialization-8.html">
            
                <a href="linux-initialization-8.html">
            
                    
                    Scheduler initialization
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.9" data-path="linux-initialization-9.html">
            
                <a href="linux-initialization-9.html">
            
                    
                    RCU initialization
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.10" data-path="linux-initialization-10.html">
            
                <a href="linux-initialization-10.html">
            
                    
                    End of initialization
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../interrupts/">
            
                <a href="../interrupts/">
            
                    
                    Interrupts
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../interrupts/interrupts-1.html">
            
                <a href="../interrupts/interrupts-1.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../interrupts/interrupts-2.html">
            
                <a href="../interrupts/interrupts-2.html">
            
                    
                    Start to dive into interrupts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../interrupts/interrupts-3.html">
            
                <a href="../interrupts/interrupts-3.html">
            
                    
                    Interrupt handlers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="../interrupts/interrupts-4.html">
            
                <a href="../interrupts/interrupts-4.html">
            
                    
                    Initialization of non-early interrupt gates
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.5" data-path="../interrupts/interrupts-5.html">
            
                <a href="../interrupts/interrupts-5.html">
            
                    
                    Implementation of some exception handlers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.6" data-path="../interrupts/interrupts-6.html">
            
                <a href="../interrupts/interrupts-6.html">
            
                    
                    Handling Non-Maskable interrupts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.7" data-path="../interrupts/interrupts-7.html">
            
                <a href="../interrupts/interrupts-7.html">
            
                    
                    Dive into external hardware interrupts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.8" data-path="../interrupts/interrupts-8.html">
            
                <a href="../interrupts/interrupts-8.html">
            
                    
                    Initialization of external hardware interrupts structures
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.9" data-path="../interrupts/interrupts-9.html">
            
                <a href="../interrupts/interrupts-9.html">
            
                    
                    Softirq, Tasklets and Workqueues
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.10" data-path="../interrupts/interrupts-10.html">
            
                <a href="../interrupts/interrupts-10.html">
            
                    
                    Last part
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../SysCall/">
            
                <a href="../SysCall/">
            
                    
                    System calls
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../SysCall/syscall-1.html">
            
                <a href="../SysCall/syscall-1.html">
            
                    
                    Introduction to system calls
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="../SysCall/syscall-2.html">
            
                <a href="../SysCall/syscall-2.html">
            
                    
                    How the Linux kernel handles a system call
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="../SysCall/syscall-3.html">
            
                <a href="../SysCall/syscall-3.html">
            
                    
                    vsyscall and vDSO
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="../SysCall/syscall-4.html">
            
                <a href="../SysCall/syscall-4.html">
            
                    
                    How the Linux kernel runs a program
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.5" data-path="../SysCall/syscall-5.html">
            
                <a href="../SysCall/syscall-5.html">
            
                    
                    Implementation of the open system call
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../Timers/">
            
                <a href="../Timers/">
            
                    
                    Timers and time management
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../Timers/timers-1.html">
            
                <a href="../Timers/timers-1.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="../Timers/timers-2.html">
            
                <a href="../Timers/timers-2.html">
            
                    
                    Clocksource framework
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="../Timers/timers-3.html">
            
                <a href="../Timers/timers-3.html">
            
                    
                    The tick broadcast framework and dyntick
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="../Timers/timers-4.html">
            
                <a href="../Timers/timers-4.html">
            
                    
                    Introduction to timers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.5" data-path="../Timers/timers-5.html">
            
                <a href="../Timers/timers-5.html">
            
                    
                    Clockevents framework
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.6" data-path="../Timers/timers-6.html">
            
                <a href="../Timers/timers-6.html">
            
                    
                    x86 related clock sources
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.7" data-path="../Timers/timers-7.html">
            
                <a href="../Timers/timers-7.html">
            
                    
                    Time related system calls
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../SyncPrim/">
            
                <a href="../SyncPrim/">
            
                    
                    Synchronization primitives
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="../SyncPrim/sync-1.html">
            
                <a href="../SyncPrim/sync-1.html">
            
                    
                    Introduction to spinlocks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="../SyncPrim/sync-2.html">
            
                <a href="../SyncPrim/sync-2.html">
            
                    
                    Queued spinlocks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="../SyncPrim/sync-3.html">
            
                <a href="../SyncPrim/sync-3.html">
            
                    
                    Semaphores
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4" data-path="../SyncPrim/sync-4.html">
            
                <a href="../SyncPrim/sync-4.html">
            
                    
                    Mutex
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5" data-path="../SyncPrim/sync-5.html">
            
                <a href="../SyncPrim/sync-5.html">
            
                    
                    Reader/Writer semaphores
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.6" data-path="../SyncPrim/sync-6.html">
            
                <a href="../SyncPrim/sync-6.html">
            
                    
                    SeqLock
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.7" >
            
                <span>
            
                    
                    RCU
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.8" >
            
                <span>
            
                    
                    Lockdep
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../mm/">
            
                <a href="../mm/">
            
                    
                    Memory management
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="../mm/linux-mm-1.html">
            
                <a href="../mm/linux-mm-1.html">
            
                    
                    Memblock
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="../mm/linux-mm-2.html">
            
                <a href="../mm/linux-mm-2.html">
            
                    
                    Fixmaps and ioremap
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="../mm/linux-mm-3.html">
            
                <a href="../mm/linux-mm-3.html">
            
                    
                    kmemcheck
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="../Cgroups/">
            
                <a href="../Cgroups/">
            
                    
                    Cgroups
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="../Cgroups/cgroups1.html">
            
                <a href="../Cgroups/cgroups1.html">
            
                    
                    Introduction to Control Groups
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" >
            
                <span>
            
                    
                    SMP
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="../Concepts/">
            
                <a href="../Concepts/">
            
                    
                    Concepts
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.11.1" data-path="../Concepts/per-cpu.html">
            
                <a href="../Concepts/per-cpu.html">
            
                    
                    Per-CPU variables
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.2" data-path="../Concepts/cpumask.html">
            
                <a href="../Concepts/cpumask.html">
            
                    
                    Cpumasks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.3" data-path="../Concepts/initcall.html">
            
                <a href="../Concepts/initcall.html">
            
                    
                    The initcall mechanism
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="../DataStructures/">
            
                <a href="../DataStructures/">
            
                    
                    Data Structures in the Linux Kernel
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.12.1" data-path="../DataStructures/dlist.html">
            
                <a href="../DataStructures/dlist.html">
            
                    
                    Doubly linked list
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.2" data-path="../DataStructures/radix-tree.html">
            
                <a href="../DataStructures/radix-tree.html">
            
                    
                    Radix tree
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.3" data-path="../DataStructures/bitmap.html">
            
                <a href="../DataStructures/bitmap.html">
            
                    
                    Bit arrays
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="../Theory/">
            
                <a href="../Theory/">
            
                    
                    Theory
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.13.1" data-path="../Theory/Paging.html">
            
                <a href="../Theory/Paging.html">
            
                    
                    Paging
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.2" data-path="../Theory/ELF.html">
            
                <a href="../Theory/ELF.html">
            
                    
                    Elf64
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.3" data-path="../Theory/asm.html">
            
                <a href="../Theory/asm.html">
            
                    
                    Inline assembly
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.4" >
            
                <span>
            
                    
                    CPUID
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.5" >
            
                <span>
            
                    
                    MSR
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.14" >
            
                <span>
            
                    
                    Initial ram disk
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.14.1" >
            
                <span>
            
                    
                    initrd
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="../Misc/">
            
                <a href="../Misc/">
            
                    
                    Misc
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.15.1" data-path="../Misc/how_kernel_compiled.html">
            
                <a href="../Misc/how_kernel_compiled.html">
            
                    
                    How the kernel is compiled
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.2" data-path="../Misc/linkers.html">
            
                <a href="../Misc/linkers.html">
            
                    
                    Linkers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.3" data-path="../Misc/contribute.html">
            
                <a href="../Misc/contribute.html">
            
                    
                    Linux kernel development
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.4" data-path="../Misc/program_startup.html">
            
                <a href="../Misc/program_startup.html">
            
                    
                    Program startup process in userspace
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.5" >
            
                <span>
            
                    
                    Write and Submit your first Linux kernel Patch
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.6" >
            
                <span>
            
                    
                    Data types in the kernel
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="../KernelStructures/">
            
                <a href="../KernelStructures/">
            
                    
                    KernelStructures
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.16.1" data-path="../KernelStructures/idt.html">
            
                <a href="../KernelStructures/idt.html">
            
                    
                    IDT
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.17" data-path="../LINKS.html">
            
                <a href="../LINKS.html">
            
                    
                    Useful links
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.18" data-path="../contributors.html">
            
                <a href="../contributors.html">
            
                    
                    Contributors
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Architecture-specific initializations, again...</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="kernel-initialization-part-6">Kernel initialization. Part 6.</h1>
<h1 id="architecture-specific-initialization-again">Architecture-specific initialization, again...</h1>
<p>In the previous <a href="http://0xax.gitbooks.io/linux-insides/content/Initialization/linux-initialization-5.html" target="_blank">part</a> we saw architecture-specific (<code>x86_64</code> in our case) initialization stuff from the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/setup.c" target="_blank">arch/x86/kernel/setup.c</a> and finished on <code>x86_configure_nx</code> function which sets the <code>_PAGE_NX</code> flag depends on support of <a href="http://en.wikipedia.org/wiki/NX_bit" target="_blank">NX bit</a>. As I wrote before <code>setup_arch</code> function and <code>start_kernel</code> are very big, so in this and in the next part we will continue to learn about architecture-specific initialization process. The next function after <code>x86_configure_nx</code> is <code>parse_early_param</code>. This function is defined in the <a href="https://github.com/torvalds/linux/blob/master/init/main.c" target="_blank">init/main.c</a> and as you can understand from its name, this function parses kernel command line and setups different services depends on the given parameters (all kernel command line parameters you can find are in the <a href="https://github.com/torvalds/linux/blob/master/Documentation/kernel-parameters.txt" target="_blank">Documentation/kernel-parameters.txt</a>). You may remember how we setup <code>earlyprintk</code> in the earliest <a href="http://0xax.gitbooks.io/linux-insides/content/Booting/linux-bootstrap-2.html" target="_blank">part</a>. On the early stage we looked for kernel parameters and their value with the <code>cmdline_find_option</code> function and <code>__cmdline_find_option</code>, <code>__cmdline_find_option_bool</code> helpers from the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/cmdline.c" target="_blank">arch/x86/boot/cmdline.c</a>. There we&apos;re in the generic kernel part which does not depend on architecture and here we use another approach. If you are reading linux kernel source code, you already note calls like this:</p>
<pre><code class="lang-C">early_param(<span class="hljs-string">&quot;gbpages&quot;</span>, parse_direct_gbpages_on);
</code></pre>
<p><code>early_param</code> macro takes two parameters:</p>
<ul>
<li>command line parameter name;</li>
<li>function which will be called if given parameter is passed.</li>
</ul>
<p>and defined as:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> early_param(str, fn) \
        __setup_param(str, fn, fn, 1)</span>
</code></pre>
<p>in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/init.h" target="_blank">include/linux/init.h</a>. As you can see <code>early_param</code> macro just makes call of the <code>__setup_param</code> macro:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __setup_param(str, unique_id, fn, early)                \
        static const char __setup_str_##unique_id[] __initconst \
                __aligned(1) = str; \
        static struct obs_kernel_param __setup_##unique_id      \
                __used __section(.init.setup)                   \
                __attribute__((aligned((sizeof(long)))))        \
                = { __setup_str_##unique_id, fn, early }</span>
</code></pre>
<p>This macro defines <code>__setup_str_*_id</code> variable (where <code>*</code> depends on given function name) and assigns it to the given command line parameter name. In the next line we can see definition of the <code>__setup_*</code> variable which type is <code>obs_kernel_param</code> and its initialization. <code>obs_kernel_param</code> structure defined as:</p>
<pre><code class="lang-C"><span class="hljs-keyword">struct</span> obs_kernel_param {
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str;
        <span class="hljs-keyword">int</span> (*setup_func)(<span class="hljs-keyword">char</span> *);
        <span class="hljs-keyword">int</span> early;
};
</code></pre>
<p>and contains three fields:</p>
<ul>
<li>name of the kernel parameter;</li>
<li>function which setups something depend on parameter;</li>
<li>field determines is parameter early (1) or not (0).</li>
</ul>
<p>Note that <code>__set_param</code> macro defines with <code>__section(.init.setup)</code> attribute. It means that all <code>__setup_str_*</code> will be placed in the <code>.init.setup</code> section, moreover, as we can see in the <a href="https://github.com/torvalds/linux/blob/master/include/asm-generic/vmlinux.lds.h" target="_blank">include/asm-generic/vmlinux.lds.h</a>, they will be placed between <code>__setup_start</code> and <code>__setup_end</code>:</p>
<pre><code>#define INIT_SETUP(initsetup_align)                \
                . = ALIGN(initsetup_align);        \
                VMLINUX_SYMBOL(__setup_start) = .; \
                *(.init.setup)                     \
                VMLINUX_SYMBOL(__setup_end) = .;
</code></pre><p>Now we know how parameters are defined, let&apos;s back to the <code>parse_early_param</code> implementation: </p>
<pre><code class="lang-C"><span class="hljs-keyword">void</span> __<span class="hljs-function">init <span class="hljs-title">parse_early_param</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> done __initdata;
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> tmp_cmdline[COMMAND_LINE_SIZE] __initdata;

        <span class="hljs-keyword">if</span> (done)
                <span class="hljs-keyword">return</span>;

        <span class="hljs-comment">/* All fall through to do_early_param. */</span>
        strlcpy(tmp_cmdline, boot_command_line, COMMAND_LINE_SIZE);
        parse_early_options(tmp_cmdline);
        done = <span class="hljs-number">1</span>;
}
</code></pre>
<p>The <code>parse_early_param</code> function defines two static variables. First <code>done</code> check that <code>parse_early_param</code> already called and the second is temporary storage for kernel command line. After this we copy <code>boot_command_line</code> to the temporary command line which we just defined and call the <code>parse_early_options</code> function from the same source code <code>main.c</code> file. <code>parse_early_options</code> calls the <code>parse_args</code> function from the <a href="https://github.com/torvalds/linux/blob/master/" target="_blank">kernel/params.c</a> where <code>parse_args</code> parses given command line and calls <code>do_early_param</code> function. This <a href="https://github.com/torvalds/linux/blob/master/init/main.c#L413" target="_blank">function</a> goes from the <code>__setup_start</code> to <code>__setup_end</code>, and calls the function from the <code>obs_kernel_param</code> if a parameter is early. After this all services which are depend on early command line parameters were setup and the next call after the <code>parse_early_param</code> is <code>x86_report_nx</code>. As I wrote in the beginning of this part, we already set <code>NX-bit</code> with the <code>x86_configure_nx</code>. The next <code>x86_report_nx</code> function from the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/mm/setup_nx.c" target="_blank">arch/x86/mm/setup_nx.c</a> just prints information about the <code>NX</code>. Note that we call <code>x86_report_nx</code> not right after the <code>x86_configure_nx</code>, but after the call of the <code>parse_early_param</code>. The answer is simple: we call it after the <code>parse_early_param</code> because the kernel support <code>noexec</code> parameter:</p>
<pre><code>noexec        [X86]
            On X86-32 available only on PAE configured kernels.
            noexec=on: enable non-executable mappings (default)
            noexec=off: disable non-executable mappings
</code></pre><p>We can see it in the booting time:</p>
<p><img src="http://oi62.tinypic.com/swwxhy.jpg" alt="NX"></p>
<p>After this we can see call of the:</p>
<pre><code class="lang-C">    memblock_x86_reserve_range_setup_data();
</code></pre>
<p>function. This function is defined in the same <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/setup.c" target="_blank">arch/x86/kernel/setup.c</a> source code file and remaps memory for the <code>setup_data</code> and reserved memory block for the <code>setup_data</code> (more about <code>setup_data</code> you can read in the previous <a href="http://0xax.gitbooks.io/linux-insides/content/Initialization/linux-initialization-5.html" target="_blank">part</a> and about <code>ioremap</code> and <code>memblock</code> you can read in the <a href="http://0xax.gitbooks.io/linux-insides/content/mm/index.html" target="_blank">Linux kernel memory management</a>).</p>
<p>In the next step we can see following conditional statement:</p>
<pre><code class="lang-C">    <span class="hljs-keyword">if</span> (acpi_mps_check()) {
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_X86_LOCAL_APIC</span>
        disable_apic = <span class="hljs-number">1</span>;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
        setup_clear_cpu_cap(X86_FEATURE_APIC);
    }
</code></pre>
<p>The first <code>acpi_mps_check</code> function from the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/acpi/boot.c" target="_blank">arch/x86/kernel/acpi/boot.c</a> depends on <code>CONFIG_X86_LOCAL_APIC</code> and <code>CONFIG_x86_MPPARSE</code> configuration options:</p>
<pre><code class="lang-C"><span class="hljs-keyword">int</span> __<span class="hljs-function">init <span class="hljs-title">acpi_mps_check</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(CONFIG_X86_LOCAL_APIC) &amp;&amp; !defined(CONFIG_X86_MPPARSE)</span>
        <span class="hljs-comment">/* mptable code is not built-in*/</span>
        <span class="hljs-keyword">if</span> (acpi_disabled || acpi_noirq) {
                printk(KERN_WARNING <span class="hljs-string">&quot;MPS support code is not built-in.\n&quot;</span>
                       <span class="hljs-string">&quot;Using acpi=off or acpi=noirq or pci=noacpi &quot;</span>
                       <span class="hljs-string">&quot;may have problem\n&quot;</span>);
                 <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        }
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>It checks the built-in <code>MPS</code> or <a href="http://en.wikipedia.org/wiki/MultiProcessor_Specification" target="_blank">MultiProcessor Specification</a> table. If <code>CONFIG_X86_LOCAL_APIC</code> is set and <code>CONFIG_x86_MPPAARSE</code> is not set, <code>acpi_mps_check</code> prints warning message if the one of the command line options: <code>acpi=off</code>, <code>acpi=noirq</code> or <code>pci=noacpi</code> passed to the kernel. If <code>acpi_mps_check</code> returns <code>1</code> it means that we disable local <a href="http://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller" target="_blank">APIC</a> and clear <code>X86_FEATURE_APIC</code> bit in the of the current CPU with the <code>setup_clear_cpu_cap</code> macro. (more about CPU mask you can read in the <a href="http://0xax.gitbooks.io/linux-insides/content/Concepts/cpumask.html" target="_blank">CPU masks</a>).</p>
<h2 id="early-pci-dump">Early PCI dump</h2>
<p>In the next step we make a dump of the <a href="http://en.wikipedia.org/wiki/Conventional_PCI" target="_blank">PCI</a> devices with the following code:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_PCI</span>
    <span class="hljs-keyword">if</span> (pci_early_dump_regs)
        early_dump_pci_devices();
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
</code></pre>
<p><code>pci_early_dump_regs</code> variable defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/pci/common.c" target="_blank">arch/x86/pci/common.c</a> and its value depends on the kernel command line parameter: <code>pci=earlydump</code>. We can find definition of this parameter in the <a href="https://github.com/torvalds/linux/blob/master/arch" target="_blank">drivers/pci/pci.c</a>:</p>
<pre><code class="lang-C">early_param(<span class="hljs-string">&quot;pci&quot;</span>, pci_setup);
</code></pre>
<p><code>pci_setup</code> function gets the string after the <code>pci=</code> and analyzes it. This function calls <code>pcibios_setup</code> which defined as <code>__weak</code> in the <a href="https://github.com/torvalds/linux/blob/master/arch" target="_blank">drivers/pci/pci.c</a> and every architecture defines the same function which overrides <code>__weak</code> analog. For example <code>x86_64</code> architecture-dependent version is in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/pci/common.c" target="_blank">arch/x86/pci/common.c</a>:</p>
<pre><code class="lang-C"><span class="hljs-keyword">char</span> *__<span class="hljs-function">init <span class="hljs-title">pcibios_setup</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str)</span> </span>{
        ...
        ...
        ...
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(str, <span class="hljs-string">&quot;earlydump&quot;</span>)) {
                pci_early_dump_regs = <span class="hljs-number">1</span>;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
        }
        ...
        ...
        ...
}
</code></pre>
<p>So, if <code>CONFIG_PCI</code> option is set and we passed <code>pci=earlydump</code> option to the kernel command line, next function which will be called - <code>early_dump_pci_devices</code> from the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/pci/early.c" target="_blank">arch/x86/pci/early.c</a>. This function checks <code>noearly</code> pci parameter with:</p>
<pre><code class="lang-C"><span class="hljs-keyword">if</span> (!early_pci_allowed())
        <span class="hljs-keyword">return</span>;
</code></pre>
<p>and returns if it was passed. Each PCI domain can host up to <code>256</code> buses and each bus hosts up to 32 devices. So, we goes in a loop:</p>
<pre><code class="lang-C"><span class="hljs-keyword">for</span> (bus = <span class="hljs-number">0</span>; bus &lt; <span class="hljs-number">256</span>; bus++) {
                <span class="hljs-keyword">for</span> (slot = <span class="hljs-number">0</span>; slot &lt; <span class="hljs-number">32</span>; slot++) {
                        <span class="hljs-keyword">for</span> (func = <span class="hljs-number">0</span>; func &lt; <span class="hljs-number">8</span>; func++) {
                        ...
                        ...
                        ...
                        }
                }
}
</code></pre>
<p>and read the <code>pci</code> config with the <code>read_pci_config</code> function.</p>
<p>That&apos;s all. We will not go deep in the <code>pci</code> details, but will see more details in the special <code>Drivers/PCI</code> part.</p>
<h2 id="finish-with-memory-parsing">Finish with memory parsing</h2>
<p>After the <code>early_dump_pci_devices</code>, there are a couple of function related with available memory and <a href="http://en.wikipedia.org/wiki/E820" target="_blank">e820</a> which we collected in the <a href="http://0xax.gitbooks.io/linux-insides/content/Booting/linux-bootstrap-2.html" target="_blank">First steps in the kernel setup</a> part:</p>
<pre><code class="lang-C">    <span class="hljs-comment">/* update the e820_saved too */</span>
    e820_reserve_setup_data();
    finish_e820_parsing();
    ...
    ...
    ...
    e820_add_kernel_range();
    trim_bios_range(<span class="hljs-keyword">void</span>);
    max_pfn = e820_end_of_ram_pfn();
    early_reserve_e820_mpc_new();
</code></pre>
<p>Let&apos;s look on it. As you can see the first function is <code>e820_reserve_setup_data</code>. This function does almost the same as <code>memblock_x86_reserve_range_setup_data</code> which we saw above, but it also calls <code>e820_update_range</code> which adds new regions to the <code>e820map</code> with the given type which is <code>E820_RESERVED_KERN</code> in our case. The next function is <code>finish_e820_parsing</code> which sanitizes <code>e820map</code> with the <code>sanitize_e820_map</code> function. Besides this two functions we can see a couple of functions related to the <a href="http://en.wikipedia.org/wiki/E820" target="_blank">e820</a>. You can see it in the listing above. <code>e820_add_kernel_range</code> function takes the physical address of the kernel start and end:</p>
<pre><code class="lang-C">u64 start = __pa_symbol(_text);
u64 size = __pa_symbol(_end) - start;
</code></pre>
<p>checks that <code>.text</code> <code>.data</code> and <code>.bss</code> marked as <code>E820RAM</code> in the <code>e820map</code> and prints the warning message if not. The next function <code>trm_bios_range</code> update first 4096 bytes in <code>e820Map</code> as <code>E820_RESERVED</code> and sanitizes it again with the call of the <code>sanitize_e820_map</code>. After this we get the last page frame number with the call of the <code>e820_end_of_ram_pfn</code> function. Every memory page has a unique number - <code>Page frame number</code>  and <code>e820_end_of_ram_pfn</code> function returns the maximum with the call of the <code>e820_end_pfn</code>:</p>
<pre><code class="lang-C"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> __<span class="hljs-function">init <span class="hljs-title">e820_end_of_ram_pfn</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    <span class="hljs-keyword">return</span> e820_end_pfn(MAX_ARCH_PFN);
}
</code></pre>
<p>where <code>e820_end_pfn</code> takes maximum page frame number on the certain architecture (<code>MAX_ARCH_PFN</code> is <code>0x400000000</code> for <code>x86_64</code>). In the <code>e820_end_pfn</code> we go through the all <code>e820</code> slots and check that <code>e820</code> entry has <code>E820_RAM</code> or <code>E820_PRAM</code> type because we calculate page frame numbers only for these types, gets the base address and end address of the page frame number for the current <code>e820</code> entry and makes some checks for these addresses:</p>
<pre><code class="lang-C"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; e820.nr_map; i++) {
        <span class="hljs-keyword">struct</span> e820entry *ei = &amp;e820.<span class="hljs-built_in">map</span>[i];
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> start_pfn;
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> end_pfn;

        <span class="hljs-keyword">if</span> (ei-&gt;type != E820_RAM &amp;&amp; ei-&gt;type != E820_PRAM)
            <span class="hljs-keyword">continue</span>;

        start_pfn = ei-&gt;addr &gt;&gt; PAGE_SHIFT;
        end_pfn = (ei-&gt;addr + ei-&gt;size) &gt;&gt; PAGE_SHIFT;

        <span class="hljs-keyword">if</span> (start_pfn &gt;= limit_pfn)
            <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">if</span> (end_pfn &gt; limit_pfn) {
            last_pfn = limit_pfn;
            <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">if</span> (end_pfn &gt; last_pfn)
            last_pfn = end_pfn;
}
</code></pre>
<pre><code class="lang-C">    <span class="hljs-keyword">if</span> (last_pfn &gt; max_arch_pfn)
        last_pfn = max_arch_pfn;

    printk(KERN_INFO <span class="hljs-string">&quot;e820: last_pfn = %#lx max_arch_pfn = %#lx\n&quot;</span>,
             last_pfn, max_arch_pfn);
    <span class="hljs-keyword">return</span> last_pfn;
</code></pre>
<p>After this we check that <code>last_pfn</code> which we got in the loop is not greater that maximum page frame number for the certain architecture (<code>x86_64</code> in our case), print information about last page frame number and return it. We can see the <code>last_pfn</code> in the <code>dmesg</code> output:</p>
<pre><code>...
[    0.000000] e820: last_pfn = 0x41f000 max_arch_pfn = 0x400000000
...
</code></pre><p>After this, as we have calculated the biggest page frame number, we calculate <code>max_low_pfn</code> which is the biggest page frame number in the <code>low memory</code> or below first <code>4</code> gigabytes. If installed more than 4 gigabytes of RAM, <code>max_low_pfn</code> will be result of the <code>e820_end_of_low_ram_pfn</code> function which does the same <code>e820_end_of_ram_pfn</code> but with 4 gigabytes limit, in other way <code>max_low_pfn</code> will be the same as <code>max_pfn</code>:</p>
<pre><code class="lang-C"><span class="hljs-keyword">if</span> (max_pfn &gt; (<span class="hljs-number">1U</span>L&lt;&lt;(<span class="hljs-number">32</span> - PAGE_SHIFT)))
    max_low_pfn = e820_end_of_low_ram_pfn();
<span class="hljs-keyword">else</span>
    max_low_pfn = max_pfn;

high_memory = (<span class="hljs-keyword">void</span> *)__va(max_pfn * PAGE_SIZE - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;
</code></pre>
<p>Next we calculate <code>high_memory</code> (defines the upper bound on direct map memory) with <code>__va</code> macro which returns a virtual address by the given physical memory.</p>
<h2 id="dmi-scanning-">DMI scanning </h2>
<p>The next step after manipulations with different memory regions and <code>e820</code> slots is collecting information about computer. We will get all information with the <a href="http://en.wikipedia.org/wiki/Desktop_Management_Interface" target="_blank">Desktop Management Interface</a> and following functions:</p>
<pre><code class="lang-C">dmi_scan_machine();
dmi_memdev_walk();
</code></pre>
<p>First is <code>dmi_scan_machine</code> defined in the <a href="https://github.com/torvalds/linux/blob/master/drivers/firmware/dmi_scan.c" target="_blank">drivers/firmware/dmi_scan.c</a>. This function goes through the <a href="http://en.wikipedia.org/wiki/System_Management_BIOS" target="_blank">System Management BIOS</a> structures and extracts information. There are two ways specified to gain access to the <code>SMBIOS</code> table: get the pointer to the <code>SMBIOS</code> table from the <a href="http://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface" target="_blank">EFI</a>&apos;s configuration table and scanning the physical memory between <code>0xF0000</code> and <code>0x10000</code> addresses. Let&apos;s look on the second approach. <code>dmi_scan_machine</code> function remaps memory between <code>0xf0000</code> and <code>0x10000</code> with the <code>dmi_early_remap</code> which just expands to the <code>early_ioremap</code>:</p>
<pre><code class="lang-C"><span class="hljs-keyword">void</span> __<span class="hljs-function">init <span class="hljs-title">dmi_scan_machine</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    <span class="hljs-keyword">char</span> __iomem *p, *q;
    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">32</span>];
    ...
    ...
    ...
    p = dmi_early_remap(<span class="hljs-number">0xF0000</span>, <span class="hljs-number">0x10000</span>);
    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)
            <span class="hljs-keyword">goto</span> error;
</code></pre>
<p>and iterates over all <code>DMI</code> header address and find search <code>_SM_</code> string:</p>
<pre><code class="lang-C"><span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">16</span>);
<span class="hljs-keyword">for</span> (q = p; q &lt; p + <span class="hljs-number">0x10000</span>; q += <span class="hljs-number">16</span>) {
        memcpy_fromio(buf + <span class="hljs-number">16</span>, q, <span class="hljs-number">16</span>);
        <span class="hljs-keyword">if</span> (!dmi_smbios3_present(buf) || !dmi_present(buf)) {
            dmi_available = <span class="hljs-number">1</span>;
            dmi_early_unmap(p, <span class="hljs-number">0x10000</span>);
            <span class="hljs-keyword">goto</span> out;
        }
        <span class="hljs-built_in">memcpy</span>(buf, buf + <span class="hljs-number">16</span>, <span class="hljs-number">16</span>);
}
</code></pre>
<p><code>_SM_</code> string must be between <code>000F0000h</code> and <code>0x000FFFFF</code>. Here we copy 16 bytes to the <code>buf</code> with <code>memcpy_fromio</code> which is the same <code>memcpy</code> and execute <code>dmi_smbios3_present</code> and <code>dmi_present</code> on the buffer. These functions check that first 4 bytes is <code>_SM_</code> string, get <code>SMBIOS</code> version and gets <code>_DMI_</code> attributes as <code>DMI</code> structure table length, table address and etc... After one of these functions finish, you will see the result of it in the <code>dmesg</code> output:</p>
<pre><code>[    0.000000] SMBIOS 2.7 present.
[    0.000000] DMI: Gigabyte Technology Co., Ltd. Z97X-UD5H-BK/Z97X-UD5H-BK, BIOS F6 06/17/2014
</code></pre><p>In the end of the <code>dmi_scan_machine</code>, we unmap the previously remapped memory:</p>
<pre><code class="lang-C">dmi_early_unmap(p, <span class="hljs-number">0x10000</span>);
</code></pre>
<p>The second function is - <code>dmi_memdev_walk</code>. As you can understand it goes over memory devices. Let&apos;s look on it:</p>
<pre><code class="lang-C"><span class="hljs-keyword">void</span> __<span class="hljs-function">init <span class="hljs-title">dmi_memdev_walk</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    <span class="hljs-keyword">if</span> (!dmi_available)
        <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">if</span> (dmi_walk_early(count_mem_devices) == <span class="hljs-number">0</span> &amp;&amp; dmi_memdev_nr) {
        dmi_memdev = dmi_alloc(<span class="hljs-keyword">sizeof</span>(*dmi_memdev) * dmi_memdev_nr);
        <span class="hljs-keyword">if</span> (dmi_memdev)
            dmi_walk_early(save_mem_devices);
    }
}
</code></pre>
<p>It checks that <code>DMI</code> available (we got it in the previous function - <code>dmi_scan_machine</code>) and collects information about memory devices with <code>dmi_walk_early</code> and <code>dmi_alloc</code> which defined as:</p>
<pre><code>#ifdef CONFIG_DMI
RESERVE_BRK(dmi_alloc, 65536);
#endif
</code></pre><p><code>RESERVE_BRK</code> defined in the <a href="http://en.wikipedia.org/wiki/Desktop_Management_Interface" target="_blank">arch/x86/include/asm/setup.h</a> and reserves space with given size in the <code>brk</code> section.</p>
<hr>
<pre><code>init_hypervisor_platform();
x86_init.resources.probe_roms();
insert_resource(&amp;iomem_resource, &amp;code_resource);
insert_resource(&amp;iomem_resource, &amp;data_resource);
insert_resource(&amp;iomem_resource, &amp;bss_resource);
early_gart_iommu_check();
</code></pre><h2 id="smp-config">SMP config</h2>
<p>The next step is parsing of the <a href="http://en.wikipedia.org/wiki/Symmetric_multiprocessing" target="_blank">SMP</a> configuration. We do it with the call of the <code>find_smp_config</code> function which just calls function:</p>
<pre><code class="lang-C"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">find_smp_config</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
        x86_init.mpparse.find_smp_config();
}
</code></pre>
<p>inside. <code>x86_init.mpparse.find_smp_config</code> is the <code>default_find_smp_config</code> function from the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/mpparse.c" target="_blank">arch/x86/kernel/mpparse.c</a>. In the <code>default_find_smp_config</code> function we are scanning a couple of memory regions for <code>SMP</code> config and return if they are found:</p>
<pre><code class="lang-C"><span class="hljs-keyword">if</span> (smp_scan_config(<span class="hljs-number">0x0</span>, <span class="hljs-number">0x400</span>) ||
            smp_scan_config(<span class="hljs-number">639</span> * <span class="hljs-number">0x400</span>, <span class="hljs-number">0x400</span>) ||
            smp_scan_config(<span class="hljs-number">0xF0000</span>, <span class="hljs-number">0x10000</span>))
            <span class="hljs-keyword">return</span>;
</code></pre>
<p>First of all <code>smp_scan_config</code> function defines a couple of variables:</p>
<pre><code class="lang-C"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *bp = phys_to_virt(base);
<span class="hljs-keyword">struct</span> mpf_intel *mpf;
</code></pre>
<p>First is virtual address of the memory region where we will scan <code>SMP</code> config, second is the pointer to the <code>mpf_intel</code> structure. Let&apos;s try to understand what is it <code>mpf_intel</code>. All information stores in the multiprocessor configuration data structure. <code>mpf_intel</code> presents this structure and looks:</p>
<pre><code class="lang-C"><span class="hljs-keyword">struct</span> mpf_intel {
        <span class="hljs-keyword">char</span> signature[<span class="hljs-number">4</span>];
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> physptr;
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> length;
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> specification;
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> checksum;
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> feature1;
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> feature2;
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> feature3;
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> feature4;
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> feature5;
};
</code></pre>
<p>As we can read in the documentation - one of the main functions of the system BIOS is to construct the MP floating pointer structure and the MP configuration table. And operating system must have access to this information about the multiprocessor configuration and <code>mpf_intel</code> stores the physical address (look at second parameter) of the multiprocessor configuration table. So, <code>smp_scan_config</code> going in a loop through the given memory range and tries to find <code>MP floating pointer structure</code> there. It checks that current byte points to the <code>SMP</code> signature, checks checksum, checks if <code>mpf-&gt;specification</code> is 1 or 4(it must be <code>1</code> or <code>4</code> by specification) in the loop:</p>
<pre><code class="lang-C"><span class="hljs-keyword">while</span> (length &gt; <span class="hljs-number">0</span>) {
<span class="hljs-keyword">if</span> ((*bp == SMP_MAGIC_IDENT) &amp;&amp;
    (mpf-&gt;length == <span class="hljs-number">1</span>) &amp;&amp;
    !mpf_checksum((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)bp, <span class="hljs-number">16</span>) &amp;&amp;
    ((mpf-&gt;specification == <span class="hljs-number">1</span>)
    || (mpf-&gt;specification == <span class="hljs-number">4</span>))) {

        mem = virt_to_phys(mpf);
        memblock_reserve(mem, <span class="hljs-keyword">sizeof</span>(*mpf));
        <span class="hljs-keyword">if</span> (mpf-&gt;physptr)
            smp_reserve_memory(mpf);
    }
}
</code></pre>
<p>reserves given memory block if search is successful with <code>memblock_reserve</code> and reserves physical address of the multiprocessor configuration table. You can find documentation about this in the - <a href="http://www.intel.com/design/pentium/datashts/24201606.pdf" target="_blank">MultiProcessor Specification</a>. You can read More details in the special part about <code>SMP</code>.</p>
<h2 id="additional-early-memory-initialization-routines">Additional early memory initialization routines</h2>
<p>In the next step of the <code>setup_arch</code> we can see the call of the <code>early_alloc_pgt_buf</code> function which allocates the page table buffer for early stage. The page table buffer will be placed in the <code>brk</code> area. Let&apos;s look on its implementation:</p>
<pre><code class="lang-C"><span class="hljs-keyword">void</span>  __<span class="hljs-function">init <span class="hljs-title">early_alloc_pgt_buf</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> tables = INIT_PGT_BUF_SIZE;
        <span class="hljs-keyword">phys_addr_t</span> base;

        base = __pa(extend_brk(tables, PAGE_SIZE));

        pgt_buf_start = base &gt;&gt; PAGE_SHIFT;
        pgt_buf_end = pgt_buf_start;
        pgt_buf_top = pgt_buf_start + (tables &gt;&gt; PAGE_SHIFT);
}
</code></pre>
<p>First of all it get the size of the page table buffer, it will be <code>INIT_PGT_BUF_SIZE</code> which is <code>(6 * PAGE_SIZE)</code> in the current linux kernel 4.0. As we got the size of the page table buffer, we call <code>extend_brk</code> function with two parameters: size and align. As you can understand from its name, this function extends the <code>brk</code> area. As we can see in the linux kernel linker script <code>brk</code> is in memory right after the <a href="http://en.wikipedia.org/wiki/.bss" target="_blank">BSS</a>:</p>
<pre><code class="lang-C">    . = ALIGN(PAGE_SIZE);
    .brk : AT(ADDR(.brk) - LOAD_OFFSET) {
        __brk_base = .;
        . += <span class="hljs-number">64</span> * <span class="hljs-number">1024</span>;        <span class="hljs-comment">/* 64k alignment slop space */</span>
        *(.brk_reservation)    <span class="hljs-comment">/* areas brk users have reserved */</span>
        __brk_limit = .;
    }
</code></pre>
<p>Or we can find it with <code>readelf</code> util:</p>
<p><img src="http://oi61.tinypic.com/71lkeu.jpg" alt="brk area"></p>
<p>After that we got physical address of the new <code>brk</code> with the <code>__pa</code> macro, we calculate the base address and the end of the page table buffer. In the next step as we got page table buffer, we reserve memory block for the brk area with the <code>reserve_brk</code> function:</p>
<pre><code class="lang-C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __<span class="hljs-function">init <span class="hljs-title">reserve_brk</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    <span class="hljs-keyword">if</span> (_brk_end &gt; _brk_start)
        memblock_reserve(__pa_symbol(_brk_start),
                 _brk_end - _brk_start);

    _brk_start = <span class="hljs-number">0</span>;
}
</code></pre>
<p>Note that in the end of the <code>reserve_brk</code>, we set <code>brk_start</code> to zero, because after this we will not allocate it anymore. The next step after reserving memory block for the <code>brk</code>, we need to unmap out-of-range memory areas in the kernel mapping with the <code>cleanup_highmap</code> function. Remember that kernel mapping is <code>__START_KERNEL_map</code> and <code>_end - _text</code> or <code>level2_kernel_pgt</code> maps the kernel <code>_text</code>, <code>data</code> and <code>bss</code>. In the start of the <code>clean_high_map</code> we define these parameters:</p>
<pre><code class="lang-C"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> vaddr = __START_KERNEL_map;
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> end = roundup((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)_end, PMD_SIZE) - <span class="hljs-number">1</span>;
<span class="hljs-keyword">pmd_t</span> *pmd = level2_kernel_pgt;
<span class="hljs-keyword">pmd_t</span> *last_pmd = pmd + PTRS_PER_PMD;
</code></pre>
<p>Now, as we defined start and end of the kernel mapping, we go in the loop through the all kernel page middle directory entries and clean entries which are not between <code>_text</code> and <code>end</code>:</p>
<pre><code class="lang-C"><span class="hljs-keyword">for</span> (; pmd &lt; last_pmd; pmd++, vaddr += PMD_SIZE) {
        <span class="hljs-keyword">if</span> (pmd_none(*pmd))
            <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">if</span> (vaddr &lt; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) _text || vaddr &gt; end)
            set_pmd(pmd, __pmd(<span class="hljs-number">0</span>));
}
</code></pre>
<p>After this we set the limit for the <code>memblock</code> allocation with the <code>memblock_set_current_limit</code> function (read more about <code>memblock</code> you can in the <a href="https://github.com/0xAX/linux-insides/blob/master/mm/linux-mm-2.md" target="_blank">Linux kernel memory management Part 2</a>), it will be <code>ISA_END_ADDRESS</code> or <code>0x100000</code> and fill the <code>memblock</code> information according to <code>e820</code> with the call of the <code>memblock_x86_fill</code> function. You can see the result of this function in the kernel initialization time:</p>
<pre><code>MEMBLOCK configuration:
 memory size = 0x1fff7ec00 reserved size = 0x1e30000
 memory.cnt  = 0x3
 memory[0x0]    [0x00000000001000-0x0000000009efff], 0x9e000 bytes flags: 0x0
 memory[0x1]    [0x00000000100000-0x000000bffdffff], 0xbfee0000 bytes flags: 0x0
 memory[0x2]    [0x00000100000000-0x0000023fffffff], 0x140000000 bytes flags: 0x0
 reserved.cnt  = 0x3
 reserved[0x0]    [0x0000000009f000-0x000000000fffff], 0x61000 bytes flags: 0x0
 reserved[0x1]    [0x00000001000000-0x00000001a57fff], 0xa58000 bytes flags: 0x0
 reserved[0x2]    [0x0000007ec89000-0x0000007fffffff], 0x1377000 bytes flags: 0x0
</code></pre><p>The rest functions after the <code>memblock_x86_fill</code> are: <code>early_reserve_e820_mpc_new</code> allocates additional slots in the <code>e820map</code> for MultiProcessor Specification table, <code>reserve_real_mode</code> - reserves low memory from <code>0x0</code> to 1 megabyte for the trampoline to the real mode (for rebooting, etc.), <code>trim_platform_memory_ranges</code> - trims certain memory regions started from <code>0x20050000</code>, <code>0x20110000</code>, etc. these regions must be excluded because <a href="http://en.wikipedia.org/wiki/Sandy_Bridge" target="_blank">Sandy Bridge</a> has problems with these regions, <code>trim_low_memory_range</code> reserves the first 4 kilobyte page in <code>memblock</code>, <code>init_mem_mapping</code> function reconstructs direct memory mapping and setups the direct mapping of the physical memory at <code>PAGE_OFFSET</code>, <code>early_trap_pf_init</code> setups <code>#PF</code> handler (we will look on it in the chapter about interrupts) and <code>setup_real_mode</code> function setups trampoline to the <a href="http://en.wikipedia.org/wiki/Real_mode" target="_blank">real mode</a> code.</p>
<p>That&apos;s all. You can note that this part will not cover all functions which are in the <code>setup_arch</code> (like <code>early_gart_iommu_check</code>, <a href="http://en.wikipedia.org/wiki/Memory_type_range_register" target="_blank">mtrr</a> initialization, etc.). As I already wrote many times, <code>setup_arch</code> is big, and linux kernel is big. That&apos;s why I can&apos;t cover every line in the linux kernel. I don&apos;t think that we missed something important, but you can say something like: each line of code is important. Yes, it&apos;s true, but I missed them anyway, because I think that it is not realistic to cover full linux kernel. Anyway we will often return to the idea that we have already seen, and if something is unfamiliar, we will cover this theme.</p>
<h2 id="conclusion">Conclusion</h2>
<p>It is the end of the sixth part about linux kernel initialization process. In this part we continued to dive in the <code>setup_arch</code> function again and it was long part, but we are not finished with it. Yes, <code>setup_arch</code> is big, hope that next part will be the last part about this function.</p>
<p>If you have any questions or suggestions write me a comment or ping me at <a href="https://twitter.com/0xAX" target="_blank">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides" target="_blank">linux-insides</a>.</strong></p>
<h2 id="links">Links</h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/MultiProcessor_Specification" target="_blank">MultiProcessor Specification</a></li>
<li><a href="http://en.wikipedia.org/wiki/NX_bit" target="_blank">NX bit</a></li>
<li><a href="https://github.com/torvalds/linux/blob/master/Documentation/kernel-parameters.txt" target="_blank">Documentation/kernel-parameters.txt</a></li>
<li><a href="http://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller" target="_blank">APIC</a></li>
<li><a href="http://0xax.gitbooks.io/linux-insides/content/Concepts/cpumask.html" target="_blank">CPU masks</a></li>
<li><a href="http://0xax.gitbooks.io/linux-insides/content/mm/index.html" target="_blank">Linux kernel memory management</a></li>
<li><a href="http://en.wikipedia.org/wiki/Conventional_PCI" target="_blank">PCI</a></li>
<li><a href="http://en.wikipedia.org/wiki/E820" target="_blank">e820</a></li>
<li><a href="http://en.wikipedia.org/wiki/System_Management_BIOS" target="_blank">System Management BIOS</a></li>
<li><a href="http://en.wikipedia.org/wiki/System_Management_BIOS" target="_blank">System Management BIOS</a></li>
<li><a href="http://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface" target="_blank">EFI</a></li>
<li><a href="http://en.wikipedia.org/wiki/Symmetric_multiprocessing" target="_blank">SMP</a></li>
<li><a href="http://www.intel.com/design/pentium/datashts/24201606.pdf" target="_blank">MultiProcessor Specification</a></li>
<li><a href="http://en.wikipedia.org/wiki/.bss" target="_blank">BSS</a></li>
<li><a href="http://www.dmtf.org/sites/default/files/standards/documents/DSP0134v2.5Final.pdf" target="_blank">SMBIOS specification</a></li>
<li><a href="http://0xax.gitbooks.io/linux-insides/content/Initialization/linux-initialization-5.html" target="_blank">Previous part</a></li>
</ul>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="linux-initialization-5.html" class="navigation navigation-prev " aria-label="Previous page: Continue architecture-specific boot-time initializations">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="linux-initialization-7.html" class="navigation navigation-next " aria-label="Next page: End of the architecture-specific initializations, almost...">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Architecture-specific initializations, again...","level":"1.3.6","depth":2,"next":{"title":"End of the architecture-specific initializations, almost...","level":"1.3.7","depth":2,"path":"Initialization/linux-initialization-7.md","ref":"Initialization/linux-initialization-7.md","articles":[]},"previous":{"title":"Continue architecture-specific boot-time initializations","level":"1.3.5","depth":2,"path":"Initialization/linux-initialization-5.md","ref":"Initialization/linux-initialization-5.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"Initialization/linux-initialization-6.md","mtime":"2019-03-28T07:54:50.392Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2019-03-28T08:02:31.511Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

