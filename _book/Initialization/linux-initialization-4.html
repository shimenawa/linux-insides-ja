
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Kernel entry point Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="linux-initialization-5.html" />
    
    
    <link rel="prev" href="linux-initialization-3.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        <li class="header">Summary</li>
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../Booting/">
            
                <a href="../Booting/">
            
                    
                    Booting
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../Booting/linux-bootstrap-1.html">
            
                <a href="../Booting/linux-bootstrap-1.html">
            
                    
                    From bootloader to kernel
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../Booting/linux-bootstrap-2.html">
            
                <a href="../Booting/linux-bootstrap-2.html">
            
                    
                    First steps in the kernel setup code
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../Booting/linux-bootstrap-3.html">
            
                <a href="../Booting/linux-bootstrap-3.html">
            
                    
                    Video mode initialization and transition to protected mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="../Booting/linux-bootstrap-4.html">
            
                <a href="../Booting/linux-bootstrap-4.html">
            
                    
                    Transition to 64-bit mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="../Booting/linux-bootstrap-5.html">
            
                <a href="../Booting/linux-bootstrap-5.html">
            
                    
                    Kernel decompression
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="./">
            
                <a href="./">
            
                    
                    Initialization
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="linux-initialization-1.html">
            
                <a href="linux-initialization-1.html">
            
                    
                    First steps in the kernel
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="linux-initialization-2.html">
            
                <a href="linux-initialization-2.html">
            
                    
                    Early interrupts handler
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="linux-initialization-3.html">
            
                <a href="linux-initialization-3.html">
            
                    
                    Last preparations before the kernel entry point
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.3.4" data-path="linux-initialization-4.html">
            
                <a href="linux-initialization-4.html">
            
                    
                    Kernel entry point
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="linux-initialization-5.html">
            
                <a href="linux-initialization-5.html">
            
                    
                    Continue architecture-specific boot-time initializations
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="linux-initialization-6.html">
            
                <a href="linux-initialization-6.html">
            
                    
                    Architecture-specific initializations, again...
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="linux-initialization-7.html">
            
                <a href="linux-initialization-7.html">
            
                    
                    End of the architecture-specific initializations, almost...
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="linux-initialization-8.html">
            
                <a href="linux-initialization-8.html">
            
                    
                    Scheduler initialization
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.9" data-path="linux-initialization-9.html">
            
                <a href="linux-initialization-9.html">
            
                    
                    RCU initialization
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.10" data-path="linux-initialization-10.html">
            
                <a href="linux-initialization-10.html">
            
                    
                    End of initialization
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../interrupts/">
            
                <a href="../interrupts/">
            
                    
                    Interrupts
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../interrupts/interrupts-1.html">
            
                <a href="../interrupts/interrupts-1.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../interrupts/interrupts-2.html">
            
                <a href="../interrupts/interrupts-2.html">
            
                    
                    Start to dive into interrupts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../interrupts/interrupts-3.html">
            
                <a href="../interrupts/interrupts-3.html">
            
                    
                    Interrupt handlers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="../interrupts/interrupts-4.html">
            
                <a href="../interrupts/interrupts-4.html">
            
                    
                    Initialization of non-early interrupt gates
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.5" data-path="../interrupts/interrupts-5.html">
            
                <a href="../interrupts/interrupts-5.html">
            
                    
                    Implementation of some exception handlers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.6" data-path="../interrupts/interrupts-6.html">
            
                <a href="../interrupts/interrupts-6.html">
            
                    
                    Handling Non-Maskable interrupts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.7" data-path="../interrupts/interrupts-7.html">
            
                <a href="../interrupts/interrupts-7.html">
            
                    
                    Dive into external hardware interrupts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.8" data-path="../interrupts/interrupts-8.html">
            
                <a href="../interrupts/interrupts-8.html">
            
                    
                    Initialization of external hardware interrupts structures
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.9" data-path="../interrupts/interrupts-9.html">
            
                <a href="../interrupts/interrupts-9.html">
            
                    
                    Softirq, Tasklets and Workqueues
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.10" data-path="../interrupts/interrupts-10.html">
            
                <a href="../interrupts/interrupts-10.html">
            
                    
                    Last part
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../SysCall/">
            
                <a href="../SysCall/">
            
                    
                    System calls
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../SysCall/syscall-1.html">
            
                <a href="../SysCall/syscall-1.html">
            
                    
                    Introduction to system calls
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="../SysCall/syscall-2.html">
            
                <a href="../SysCall/syscall-2.html">
            
                    
                    How the Linux kernel handles a system call
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="../SysCall/syscall-3.html">
            
                <a href="../SysCall/syscall-3.html">
            
                    
                    vsyscall and vDSO
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="../SysCall/syscall-4.html">
            
                <a href="../SysCall/syscall-4.html">
            
                    
                    How the Linux kernel runs a program
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.5" data-path="../SysCall/syscall-5.html">
            
                <a href="../SysCall/syscall-5.html">
            
                    
                    Implementation of the open system call
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../Timers/">
            
                <a href="../Timers/">
            
                    
                    Timers and time management
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../Timers/timers-1.html">
            
                <a href="../Timers/timers-1.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="../Timers/timers-2.html">
            
                <a href="../Timers/timers-2.html">
            
                    
                    Clocksource framework
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="../Timers/timers-3.html">
            
                <a href="../Timers/timers-3.html">
            
                    
                    The tick broadcast framework and dyntick
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="../Timers/timers-4.html">
            
                <a href="../Timers/timers-4.html">
            
                    
                    Introduction to timers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.5" data-path="../Timers/timers-5.html">
            
                <a href="../Timers/timers-5.html">
            
                    
                    Clockevents framework
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.6" data-path="../Timers/timers-6.html">
            
                <a href="../Timers/timers-6.html">
            
                    
                    x86 related clock sources
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.7" data-path="../Timers/timers-7.html">
            
                <a href="../Timers/timers-7.html">
            
                    
                    Time related system calls
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../SyncPrim/">
            
                <a href="../SyncPrim/">
            
                    
                    Synchronization primitives
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="../SyncPrim/sync-1.html">
            
                <a href="../SyncPrim/sync-1.html">
            
                    
                    Introduction to spinlocks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="../SyncPrim/sync-2.html">
            
                <a href="../SyncPrim/sync-2.html">
            
                    
                    Queued spinlocks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="../SyncPrim/sync-3.html">
            
                <a href="../SyncPrim/sync-3.html">
            
                    
                    Semaphores
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4" data-path="../SyncPrim/sync-4.html">
            
                <a href="../SyncPrim/sync-4.html">
            
                    
                    Mutex
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5" data-path="../SyncPrim/sync-5.html">
            
                <a href="../SyncPrim/sync-5.html">
            
                    
                    Reader/Writer semaphores
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.6" data-path="../SyncPrim/sync-6.html">
            
                <a href="../SyncPrim/sync-6.html">
            
                    
                    SeqLock
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.7" >
            
                <span>
            
                    
                    RCU
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.8" >
            
                <span>
            
                    
                    Lockdep
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../mm/">
            
                <a href="../mm/">
            
                    
                    Memory management
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="../mm/linux-mm-1.html">
            
                <a href="../mm/linux-mm-1.html">
            
                    
                    Memblock
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="../mm/linux-mm-2.html">
            
                <a href="../mm/linux-mm-2.html">
            
                    
                    Fixmaps and ioremap
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="../mm/linux-mm-3.html">
            
                <a href="../mm/linux-mm-3.html">
            
                    
                    kmemcheck
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="../Cgroups/">
            
                <a href="../Cgroups/">
            
                    
                    Cgroups
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="../Cgroups/cgroups1.html">
            
                <a href="../Cgroups/cgroups1.html">
            
                    
                    Introduction to Control Groups
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" >
            
                <span>
            
                    
                    SMP
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="../Concepts/">
            
                <a href="../Concepts/">
            
                    
                    Concepts
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.11.1" data-path="../Concepts/per-cpu.html">
            
                <a href="../Concepts/per-cpu.html">
            
                    
                    Per-CPU variables
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.2" data-path="../Concepts/cpumask.html">
            
                <a href="../Concepts/cpumask.html">
            
                    
                    Cpumasks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.3" data-path="../Concepts/initcall.html">
            
                <a href="../Concepts/initcall.html">
            
                    
                    The initcall mechanism
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="../DataStructures/">
            
                <a href="../DataStructures/">
            
                    
                    Data Structures in the Linux Kernel
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.12.1" data-path="../DataStructures/dlist.html">
            
                <a href="../DataStructures/dlist.html">
            
                    
                    Doubly linked list
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.2" data-path="../DataStructures/radix-tree.html">
            
                <a href="../DataStructures/radix-tree.html">
            
                    
                    Radix tree
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.3" data-path="../DataStructures/bitmap.html">
            
                <a href="../DataStructures/bitmap.html">
            
                    
                    Bit arrays
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="../Theory/">
            
                <a href="../Theory/">
            
                    
                    Theory
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.13.1" data-path="../Theory/Paging.html">
            
                <a href="../Theory/Paging.html">
            
                    
                    Paging
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.2" data-path="../Theory/ELF.html">
            
                <a href="../Theory/ELF.html">
            
                    
                    Elf64
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.3" data-path="../Theory/asm.html">
            
                <a href="../Theory/asm.html">
            
                    
                    Inline assembly
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.4" >
            
                <span>
            
                    
                    CPUID
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.5" >
            
                <span>
            
                    
                    MSR
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.14" >
            
                <span>
            
                    
                    Initial ram disk
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.14.1" >
            
                <span>
            
                    
                    initrd
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="../Misc/">
            
                <a href="../Misc/">
            
                    
                    Misc
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.15.1" data-path="../Misc/how_kernel_compiled.html">
            
                <a href="../Misc/how_kernel_compiled.html">
            
                    
                    How the kernel is compiled
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.2" data-path="../Misc/linkers.html">
            
                <a href="../Misc/linkers.html">
            
                    
                    Linkers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.3" data-path="../Misc/contribute.html">
            
                <a href="../Misc/contribute.html">
            
                    
                    Linux kernel development
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.4" data-path="../Misc/program_startup.html">
            
                <a href="../Misc/program_startup.html">
            
                    
                    Program startup process in userspace
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.5" >
            
                <span>
            
                    
                    Write and Submit your first Linux kernel Patch
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.6" >
            
                <span>
            
                    
                    Data types in the kernel
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="../KernelStructures/">
            
                <a href="../KernelStructures/">
            
                    
                    KernelStructures
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.16.1" data-path="../KernelStructures/idt.html">
            
                <a href="../KernelStructures/idt.html">
            
                    
                    IDT
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.17" data-path="../LINKS.html">
            
                <a href="../LINKS.html">
            
                    
                    Useful links
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.18" data-path="../contributors.html">
            
                <a href="../contributors.html">
            
                    
                    Contributors
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Kernel entry point</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="kernel-initialization-part-4">Kernel initialization. Part 4.</h1>
<h1 id="kernel-entry-point">Kernel entry point</h1>
<p>If you have read the previous part - <a href="https://github.com/0xAX/linux-insides/blob/master/Initialization/linux-initialization-3.md" target="_blank">Last preparations before the kernel entry point</a>, you can remember that we finished all pre-initialization stuff and stopped right before the call to the <code>start_kernel</code> function from the <a href="https://github.com/torvalds/linux/blob/master/init/main.c" target="_blank">init/main.c</a>. The <code>start_kernel</code> is the entry of the generic and architecture independent kernel code, although we will return to the <code>arch/</code> folder many times. If you look inside of the <code>start_kernel</code> function, you will see that this function is very big. For this moment it contains about <code>86</code> calls of functions. Yes, it&apos;s very big and of course this part will not cover all the processes that occur in this function. In the current part we will only start to do it. This part and all the next which will be in the <a href="https://github.com/0xAX/linux-insides/blob/master/Initialization/README.md" target="_blank">Kernel initialization process</a> chapter will cover it.</p>
<p>The main purpose of the <code>start_kernel</code> to finish kernel initialization process and launch the first <code>init</code> process. Before the first process will be started, the <code>start_kernel</code> must do many things such as: to enable <a href="https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt" target="_blank">lock validator</a>, to initialize processor id, to enable early <a href="http://en.wikipedia.org/wiki/Cgroups" target="_blank">cgroups</a> subsystem, to setup per-cpu areas, to initialize different caches in <a href="http://en.wikipedia.org/wiki/Virtual_file_system" target="_blank">vfs</a>, to initialize memory manager, rcu, vmalloc, scheduler, IRQs, ACPI and many many more. Only after these steps will we see the launch of the first <code>init</code> process in the last part of this chapter. So much kernel code awaits us, let&apos;s start.</p>
<p><strong>NOTE: All parts from this big chapter <code>Linux Kernel initialization process</code> will not cover anything about debugging. There will be a separate chapter about kernel debugging tips.</strong></p>
<h2 id="a-little-about-function-attributes">A little about function attributes</h2>
<p>As I wrote above, the <code>start_kernel</code> function is defined in the <a href="https://github.com/torvalds/linux/blob/master/init/main.c" target="_blank">init/main.c</a>. This function defined with the <code>__init</code> attribute and as you already may know from other parts, all functions which are defined with this attribute are necessary during kernel initialization.</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __init      __section(.init.text) __cold notrace</span>
</code></pre>
<p>After the initialization process have finished, the kernel will release these sections with a call to the <code>free_initmem</code> function. Note also that <code>__init</code> is defined with two attributes: <code>__cold</code> and <code>notrace</code>. The purpose of the first <code>cold</code> attribute is to mark that the function is rarely used and the compiler must optimize this function for size. The second <code>notrace</code> is defined as:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> notrace __attribute__((no_instrument_function))</span>
</code></pre>
<p>where <code>no_instrument_function</code> says to the compiler not to generate profiling function calls.</p>
<p>In the definition of the <code>start_kernel</code> function, you can also see the <code>__visible</code> attribute which expands to the:</p>
<pre><code>#define __visible __attribute__((externally_visible))
</code></pre><p>where <code>externally_visible</code> tells to the compiler that something uses this function or variable, to prevent marking this function/variable as <code>unusable</code>. You can find the definition of this and other macro attributes in <a href="https://github.com/torvalds/linux/blob/master/include/linux/init.h" target="_blank">include/linux/init.h</a>.</p>
<h2 id="first-steps-in-the-startkernel">First steps in the start_kernel</h2>
<p>At the beginning of the <code>start_kernel</code> you can see the definition of these two variables:</p>
<pre><code class="lang-C"><span class="hljs-keyword">char</span> *command_line;
<span class="hljs-keyword">char</span> *after_dashes;
</code></pre>
<p>The first represents a pointer to the kernel command line and the second will contain the result of the <code>parse_args</code> function which parses an input string with parameters in the form <code>name=value</code>, looking for specific keywords and invoking the right handlers. We will not go into the details related with these two variables at this time, but will see it in the next parts. In the next step we can see a call to the <code>set_task_stack_end_magic</code> function. This function takes address of the <code>init_task</code> and sets <code>STACK_END_MAGIC</code> (<code>0x57AC6E9D</code>) as canary for it. <code>init_task</code> represents the initial task structure:</p>
<pre><code class="lang-C"><span class="hljs-keyword">struct</span> task_struct init_task = INIT_TASK(init_task);
</code></pre>
<p>where <code>task_struct</code> stores all the information about a process. I will not explain this structure in this book because it&apos;s very big. You can find its definition in <a href="https://github.com/torvalds/linux/blob/master/include/linux/sched.h#L1278" target="_blank">include/linux/sched.h</a>. At this moment <code>task_struct</code> contains more than <code>100</code> fields! Although you will not see the explanation of the <code>task_struct</code> in this book, we will use it very often since it is the fundamental structure which describes the <code>process</code> in the Linux kernel. I will describe the meaning of the fields of this structure as we meet them in practice.</p>
<p>You can see the definition of the <code>init_task</code> and it initialized by the <code>INIT_TASK</code> macro. This macro is from <a href="https://github.com/torvalds/linux/blob/master/include/linux/init_task.h" target="_blank">include/linux/init_task.h</a> and it just fills the <code>init_task</code> with the values for the first process. For example it sets:</p>
<ul>
<li>init process state to zero or <code>runnable</code>. A runnable process is one which is waiting only for a CPU to run on;</li>
<li>init process flags - <code>PF_KTHREAD</code> which means - kernel thread;</li>
<li>a list of runnable task;</li>
<li>process address space;</li>
<li>init process stack to the <code>&amp;init_thread_info</code> which is <code>init_thread_union.thread_info</code> and <code>initthread_union</code> has type - <code>thread_union</code> which contains <code>thread_info</code> and process stack:</li>
</ul>
<pre><code class="lang-C"><span class="hljs-keyword">union</span> thread_union {
    <span class="hljs-keyword">struct</span> thread_info thread_info;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-built_in">stack</span>[THREAD_SIZE/<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span>)];
};
</code></pre>
<p>Every process has its own stack and it is 16 kilobytes or 4 page frames. in <code>x86_64</code>. We can note that it is defined as array of <code>unsigned long</code>. The next field of the <code>thread_union</code> is - <code>thread_info</code> defined as:</p>
<pre><code class="lang-C"><span class="hljs-keyword">struct</span> thread_info {
        <span class="hljs-keyword">struct</span> task_struct      *task;
        <span class="hljs-keyword">struct</span> exec_domain      *exec_domain;
        __u32                   flags; 
        __u32                   status;
        __u32                   cpu;
        <span class="hljs-keyword">int</span>                     saved_preempt_count;
        <span class="hljs-keyword">mm_segment_t</span>            addr_limit;
        <span class="hljs-keyword">struct</span> restart_block    restart_block;
        <span class="hljs-keyword">void</span> __user             *sysenter_return;
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>            sig_on_uaccess_error:<span class="hljs-number">1</span>;
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>            uaccess_err:<span class="hljs-number">1</span>;
};
</code></pre>
<p>and occupies 52 bytes. The <code>thread_info</code> structure contains architecture-specific information on the thread. We know that on <code>x86_64</code> the stack grows down and <code>thread_union.thread_info</code> is stored at the bottom of the stack in our case. So the process stack is 16 kilobytes and <code>thread_info</code> is at the bottom. The remaining thread_size will be <code>16 kilobytes - 62 bytes = 16332 bytes</code>. Note that <code>thread_union</code> represented as the <a href="http://en.wikipedia.org/wiki/Union_type" target="_blank">union</a> and not structure, it means that <code>thread_info</code> and stack share the memory space.</p>
<p>Schematically it can be represented as follows:</p>
<pre><code class="lang-C">+-----------------------+
|                       |
|                       |
|        <span class="hljs-built_in">stack</span>          |
|                       |
|_______________________|
|          |            |
|          |            |
|          |            |
|__________&#x2193;____________|             +--------------------+
|                       |             |                    |
|      thread_info      |&lt;-----------&gt;|     task_struct    |
|                       |             |                    |
+-----------------------+             +--------------------+
</code></pre>
<p><a href="http://www.quora.com/In-Linux-kernel-Why-thread_info-structure-and-the-kernel-stack-of-a-process-binds-in-union-construct" target="_blank">http://www.quora.com/In-Linux-kernel-Why-thread_info-structure-and-the-kernel-stack-of-a-process-binds-in-union-construct</a></p>
<p>So the <code>INIT_TASK</code> macro fills these <code>task_struct&apos;s</code> fields and many many more. As I already wrote above, I will not describe all the fields and values in the <code>INIT_TASK</code> macro but we will see them soon.</p>
<p>Now let&apos;s go back to the <code>set_task_stack_end_magic</code> function. This function defined in the <a href="https://github.com/torvalds/linux/blob/master/kernel/fork.c#L297" target="_blank">kernel/fork.c</a> and sets a <a href="http://en.wikipedia.org/wiki/Stack_buffer_overflow" target="_blank">canary</a> to the <code>init</code> process stack to prevent stack overflow.</p>
<pre><code class="lang-C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_task_stack_end_magic</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *tsk)</span>
</span>{
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *stackend;
    stackend = end_of_stack(tsk);
    *stackend = STACK_END_MAGIC; <span class="hljs-comment">/* for overflow detection */</span>
}
</code></pre>
<p>Its implementation is simple. <code>set_task_stack_end_magic</code> gets the end of the stack for the given <code>task_struct</code> with the <code>end_of_stack</code> function. Earlier (and now for all architectures besides <code>x86_64</code>) stack was located in the <code>thread_info</code> structure. So the end of a process stack depends on the <code>CONFIG_STACK_GROWSUP</code> configuration option. As we learn in <code>x86_64</code> architecture, the stack grows down. So the end of the process stack will be:</p>
<pre><code class="lang-C">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *)(task_thread_info(p) + <span class="hljs-number">1</span>);
</code></pre>
<p>where <code>task_thread_info</code> just returns the stack which we filled with the <code>INIT_TASK</code> macro:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> task_thread_info(task)  ((struct thread_info *)(task)-&gt;stack)</span>
</code></pre>
<p>From the Linux kernel <code>v4.9-rc1</code> release, <code>thread_info</code> structure may contains only flags and stack pointer resides in <code>task_struct</code> structure which represents a thread in the Linux kernel. This depends on <code>CONFIG_THREAD_INFO_IN_TASK</code> kernel configuration option which is enabled by default for <code>x86_64</code>. You can be sure in this if you will look in the <a href="https://github.com/torvalds/linux/blob/master/init/main.c" target="_blank">init/main.c</a> configuration build file:</p>
<pre><code>config THREAD_INFO_IN_TASK
    bool
    help
      Select this to move thread_info off the stack into task_struct.  To
      make this work, an arch will need to remove all thread_info fields
      except flags and fix any runtime bugs.

      One subtle change that will be needed is to use try_get_task_stack()
      and put_task_stack() in save_thread_stack_tsk() and get_wchan().
</code></pre><p>and <a href="https://github.com/torvalds/linux/blob/master/arch/x86/Kconfig" target="_blank">arch/x86/Kconfig</a>:</p>
<pre><code>config X86
    def_bool y
        ...
        ...
        ...
        select THREAD_INFO_IN_TASK
        ...
        ...
        ...
</code></pre><p>So, in this way we may just get end of a thread stack from the given <code>task_struct</code> structure:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_THREAD_INFO_IN_TASK</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *<span class="hljs-title">end_of_stack</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> task_struct *task)</span>
</span>{
    <span class="hljs-keyword">return</span> task-&gt;<span class="hljs-built_in">stack</span>;
}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
</code></pre>
<p>As we got the end of the init process stack, we write <code>STACK_END_MAGIC</code> there. After <code>canary</code> is set, we can check it like this:</p>
<pre><code class="lang-C"><span class="hljs-keyword">if</span> (*end_of_stack(task) != STACK_END_MAGIC) {
        <span class="hljs-comment">//</span>
        <span class="hljs-comment">// handle stack overflow here</span>
    <span class="hljs-comment">//</span>
}
</code></pre>
<p>The next function after the <code>set_task_stack_end_magic</code> is <code>smp_setup_processor_id</code>. This function has an empty body for <code>x86_64</code>:</p>
<pre><code class="lang-C"><span class="hljs-keyword">void</span> __init __<span class="hljs-function">weak <span class="hljs-title">smp_setup_processor_id</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
}
</code></pre>
<p>as it not implemented for all architectures, but some such as <a href="http://en.wikipedia.org/wiki/IBM_ESA/390" target="_blank">s390</a> and <a href="http://en.wikipedia.org/wiki/ARM_architecture#64.2F32-bit_architecture" target="_blank">arm64</a>.</p>
<p>The next function in <code>start_kernel</code> is <code>debug_objects_early_init</code>. Implementation of this function is almost the same as <code>lockdep_init</code>, but fills hashes for object debugging. As I wrote above, we will not see the explanation of this and other functions which are for debugging purposes in this chapter.</p>
<p>After the <code>debug_object_early_init</code> function we can see the call of the <code>boot_init_stack_canary</code> function which fills <code>task_struct-&gt;canary</code> with the canary value for the <code>-fstack-protector</code> gcc feature. This function depends on the <code>CONFIG_CC_STACKPROTECTOR</code> configuration option and if this option is disabled, <code>boot_init_stack_canary</code> does nothing, otherwise it generates random numbers based on random pool and the <a href="http://en.wikipedia.org/wiki/Time_Stamp_Counter" target="_blank">TSC</a>:</p>
<pre><code class="lang-C">get_random_bytes(&amp;canary, <span class="hljs-keyword">sizeof</span>(canary));
tsc = __native_read_tsc();
canary += tsc + (tsc &lt;&lt; <span class="hljs-number">32U</span>L);
</code></pre>
<p>After we got a random number, we fill the <code>stack_canary</code> field of <code>task_struct</code> with it:</p>
<pre><code class="lang-C">current-&gt;stack_canary = canary;
</code></pre>
<p>and write this value to the top of the IRQ stack with the:</p>
<pre><code class="lang-C">this_cpu_write(irq_stack_union.stack_canary, canary); <span class="hljs-comment">// read below about this_cpu_write</span>
</code></pre>
<p>Again, we will not dive into details here, we will cover it in the part about <a href="http://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29" target="_blank">IRQs</a>. As canary is set, we disable local and early boot IRQs and register the bootstrap CPU in the CPU maps. We disable local IRQs (interrupts for current CPU) with the <code>local_irq_disable</code> macro which expands to the call of the <code>arch_local_irq_disable</code> function from <a href="https://github.com/torvalds/linux/blob/master/include/linux/percpu-defs.h" target="_blank">include/linux/percpu-defs.h</a>:</p>
<pre><code class="lang-C"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> notrace <span class="hljs-keyword">void</span> <span class="hljs-title">arch_local_irq_enable</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
        native_irq_enable();
}
</code></pre>
<p>Where <code>native_irq_enable</code> is <code>cli</code> instruction for <code>x86_64</code>. As interrupts are disabled we can register the current CPU with the given ID in the CPU bitmap.</p>
<h2 id="the-first-processor-activation">The first processor activation</h2>
<p>The current function from the <code>start_kernel</code> is <code>boot_cpu_init</code>. This function initializes various CPU masks for the bootstrap processor. First of all it gets the bootstrap processor id with a call to:</p>
<pre><code class="lang-C"><span class="hljs-keyword">int</span> cpu = smp_processor_id();
</code></pre>
<p>For now it is just zero. If the <code>CONFIG_DEBUG_PREEMPT</code> configuration option is disabled, <code>smp_processor_id</code> just expands to the call of <code>raw_smp_processor_id</code> which expands to the:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> raw_smp_processor_id() (this_cpu_read(cpu_number))</span>
</code></pre>
<p><code>this_cpu_read</code> as many other function like this (<code>this_cpu_write</code>, <code>this_cpu_add</code> and etc...) defined in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/percpu-defs.h" target="_blank">include/linux/percpu-defs.h</a> and presents <code>this_cpu</code> operation. These operations provide a way of optimizing access to the <a href="http://0xax.gitbooks.io/linux-insides/content/Theory/per-cpu.html" target="_blank">per-cpu</a> variables which are associated with the current processor. In our case it is <code>this_cpu_read</code>:</p>
<pre><code>__pcpu_size_call_return(this_cpu_read_, pcp)
</code></pre><p>Remember that we have passed <code>cpu_number</code> as <code>pcp</code> to the <code>this_cpu_read</code> from the <code>raw_smp_processor_id</code>. Now let&apos;s look at the <code>__pcpu_size_call_return</code> implementation:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __pcpu_size_call_return(stem, variable)                         \
({                                                                      \
        typeof(variable) pscr_ret__;                                    \
        __verify_pcpu_ptr(&amp;(variable));                                 \
        switch(sizeof(variable)) {                                      \
        case 1: pscr_ret__ = stem##1(variable); break;                  \
        case 2: pscr_ret__ = stem##2(variable); break;                  \
        case 4: pscr_ret__ = stem##4(variable); break;                  \
        case 8: pscr_ret__ = stem##8(variable); break;                  \
        default:                                                        \
                __bad_size_call_parameter(); break;                     \
        }                                                               \
        pscr_ret__;                                                     \
})</span>
</code></pre>
<p>Yes, it looks a little strange but it&apos;s easy. First of all we can see the definition of the <code>pscr_ret__</code> variable with the <code>int</code> type. Why int? Ok, <code>variable</code> is <code>common_cpu</code> and it was declared as per-cpu int variable:</p>
<pre><code class="lang-C">DECLARE_PER_CPU_READ_MOSTLY(<span class="hljs-keyword">int</span>, cpu_number);
</code></pre>
<p>In the next step we call <code>__verify_pcpu_ptr</code> with the address of <code>cpu_number</code>. <code>__veryf_pcpu_ptr</code> used to verify that the given parameter is a per-cpu pointer. After that we set <code>pscr_ret__</code> value which depends on the size of the variable. Our <code>common_cpu</code> variable is <code>int</code>, so it 4 bytes in size. It means that we will get <code>this_cpu_read_4(common_cpu)</code> in <code>pscr_ret__</code>. In the end of the <code>__pcpu_size_call_return</code> we just call it. <code>this_cpu_read_4</code> is a macro:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> this_cpu_read_4(pcp)       percpu_from_op(<span class="hljs-string">&quot;mov&quot;</span>, pcp)</span>
</code></pre>
<p>which calls <code>percpu_from_op</code> and pass <code>mov</code> instruction and per-cpu variable there. <code>percpu_from_op</code> will expand to the inline assembly call:</p>
<pre><code class="lang-C"><span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;movl %%gs:%1,%0&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span> (pfo_ret__) : <span class="hljs-string">&quot;m&quot;</span> (common_cpu))
</code></pre>
<p>Let&apos;s try to understand how it works and what it does. The <code>gs</code> segment register contains the base of per-cpu area. Here we just copy <code>common_cpu</code> which is in memory to the <code>pfo_ret__</code> with the <code>movl</code> instruction. Or with another words:</p>
<pre><code class="lang-C">this_cpu_read(common_cpu)
</code></pre>
<p>is the same as:</p>
<pre><code class="lang-C">movl %gs:$common_cpu, $pfo_ret__
</code></pre>
<p>As we didn&apos;t setup per-cpu area, we have only one - for the current running CPU, we will get <code>zero</code> as a result of the <code>smp_processor_id</code>.</p>
<p>As we got the current processor id, <code>boot_cpu_init</code> sets the given CPU online, active, present and possible with the:</p>
<pre><code class="lang-C">set_cpu_online(cpu, <span class="hljs-literal">true</span>);
set_cpu_active(cpu, <span class="hljs-literal">true</span>);
set_cpu_present(cpu, <span class="hljs-literal">true</span>);
set_cpu_possible(cpu, <span class="hljs-literal">true</span>);
</code></pre>
<p>All of these functions use the concept - <code>cpumask</code>. <code>cpu_possible</code> is a set of CPU ID&apos;s which can be plugged in at any time during the life of that system boot. <code>cpu_present</code> represents which CPUs are currently plugged in. <code>cpu_online</code> represents subset of the <code>cpu_present</code> and indicates CPUs which are available for scheduling. These masks depend on the <code>CONFIG_HOTPLUG_CPU</code> configuration option and if this option is disabled <code>possible == present</code> and <code>active == online</code>. Implementation of the all of these functions are very similar. Every function checks the second parameter. If it is <code>true</code>, it calls <code>cpumask_set_cpu</code> or <code>cpumask_clear_cpu</code> otherwise.</p>
<p>For example let&apos;s look at <code>set_cpu_possible</code>. As we passed <code>true</code> as the second parameter, the:</p>
<pre><code class="lang-C">cpumask_set_cpu(cpu, to_cpumask(cpu_possible_bits));
</code></pre>
<p>will be called. First of all let&apos;s try to understand the <code>to_cpumask</code> macro. This macro casts a bitmap to a <code>struct cpumask *</code>. CPU masks provide a bitmap suitable for representing the set of CPU&apos;s in a system, one bit position per CPU number. CPU mask presented by the <code>cpu_mask</code> structure:</p>
<pre><code class="lang-C"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> cpumask { DECLARE_BITMAP(bits, NR_CPUS); } <span class="hljs-keyword">cpumask_t</span>;
</code></pre>
<p>which is just bitmap declared with the <code>DECLARE_BITMAP</code> macro:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DECLARE_BITMAP(name, bits) unsigned long name[BITS_TO_LONGS(bits)]</span>
</code></pre>
<p>As we can see from its definition, the <code>DECLARE_BITMAP</code> macro expands to the array of <code>unsigned long</code>. Now let&apos;s look at how the <code>to_cpumask</code> macro is implemented:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> to_cpumask(bitmap)                                              \
        ((struct cpumask *)(1 ? (bitmap)                                \
                            : (void *)sizeof(__check_is_bitmap(bitmap))))</span>
</code></pre>
<p>I don&apos;t know about you, but it looked really weird for me at the first time. We can see a ternary operator here which is <code>true</code> every time, but why the <code>__check_is_bitmap</code> here? It&apos;s simple, let&apos;s look at it:</p>
<pre><code class="lang-C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> __check_is_bitmap(<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *bitmap)
{
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</code></pre>
<p>Yeah, it just returns <code>1</code> every time. Actually we need in it here only for one purpose: at compile time it checks that the given <code>bitmap</code> is a bitmap, or in other words it checks that the given <code>bitmap</code> has a type of <code>unsigned long *</code>. So we just pass <code>cpu_possible_bits</code> to the <code>to_cpumask</code> macro for converting the array of <code>unsigned long</code> to the <code>struct cpumask *</code>. Now we can call <code>cpumask_set_cpu</code> function with the <code>cpu</code> - 0 and <code>struct cpumask *cpu_possible_bits</code>. This function makes only one call of the <code>set_bit</code> function which sets the given <code>cpu</code> in the cpumask. All of these <code>set_cpu_*</code> functions work on the same principle.</p>
<p>If you&apos;re not sure that this <code>set_cpu_*</code> operations and <code>cpumask</code> are not clear for you, don&apos;t worry about it. You can get more info by reading the special part about it - <a href="http://0xax.gitbooks.io/linux-insides/content/Concepts/cpumask.html" target="_blank">cpumask</a> or <a href="https://www.kernel.org/doc/Documentation/cpu-hotplug.txt" target="_blank">documentation</a>.</p>
<p>As we activated the bootstrap processor, it&apos;s time to go to the next function in the <code>start_kernel.</code> Now it is <code>page_address_init</code>, but this function does nothing in our case, because it executes only when all <code>RAM</code> can&apos;t be mapped directly.</p>
<h2 id="print-linux-banner">Print linux banner</h2>
<p>The next call is <code>pr_notice</code>:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pr_notice(fmt, ...) \
    printk(KERN_NOTICE pr_fmt(fmt), ##__VA_ARGS__)</span>
</code></pre>
<p>as you can see it just expands to the <code>printk</code> call. At this moment we use <code>pr_notice</code> to print the Linux banner:</p>
<pre><code class="lang-C">pr_notice(<span class="hljs-string">&quot;%s&quot;</span>, linux_banner);
</code></pre>
<p>which is just the kernel version with some additional parameters:</p>
<pre><code>Linux version 4.0.0-rc6+ (alex@localhost) (gcc version 4.9.1 (Ubuntu 4.9.1-16ubuntu6) ) #319 SMP
</code></pre><h2 id="architecture-dependent-parts-of-initialization">Architecture-dependent parts of initialization</h2>
<p>The next step is architecture-specific initialization. The Linux kernel does it with the call of the <code>setup_arch</code> function. This is a very big function like <code>start_kernel</code> and we do not have time to consider all of its implementation in this part. Here we&apos;ll only start to do it and continue in the next part. As it is <code>architecture-specific</code>, we need to go again to the <code>arch/</code> directory. The <code>setup_arch</code> function defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/setup.c" target="_blank">arch/x86/kernel/setup.c</a> source code file and takes only one argument - address of the kernel command line.</p>
<p>This function starts from the reserving memory block for the kernel <code>_text</code> and <code>_data</code> which starts from the <code>_text</code> symbol (you can remember it from the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/head_64.S#L46" target="_blank">arch/x86/kernel/head_64.S</a>) and ends before <code>__bss_stop</code>. We are using <code>memblock</code> for the reserving of memory block:</p>
<pre><code class="lang-C">memblock_reserve(__pa_symbol(_text), (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)__bss_stop - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)_text);
</code></pre>
<p>You can read about <code>memblock</code> in the <a href="http://0xax.gitbooks.io/linux-insides/content/mm/linux-mm-1.html" target="_blank">Linux kernel memory management Part 1.</a>. As you can remember <code>memblock_reserve</code> function takes two parameters:</p>
<ul>
<li>base physical address of a memory block;</li>
<li>size of a memory block.</li>
</ul>
<p>We can get the base physical address of the <code>_text</code> symbol with the <code>__pa_symbol</code> macro:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __pa_symbol(x) \
    __phys_addr_symbol(__phys_reloc_hide((unsigned long)(x)))</span>
</code></pre>
<p>First of all it calls <code>__phys_reloc_hide</code> macro on the given parameter. The <code>__phys_reloc_hide</code> macro does nothing for <code>x86_64</code> and just returns the given parameter. Implementation of the <code>__phys_addr_symbol</code> macro is easy. It just subtracts the symbol address from the base address of the kernel text mapping base virtual address (you can remember that it is <code>__START_KERNEL_map</code>) and adds <code>phys_base</code> which is the base address of <code>_text</code>:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __phys_addr_symbol(x) \
 ((unsigned long)(x) - __START_KERNEL_map + phys_base)</span>
</code></pre>
<p>After we got the physical address of the <code>_text</code> symbol, <code>memblock_reserve</code> can reserve a memory block from the <code>_text</code> to the <code>__bss_stop - _text</code>.</p>
<h2 id="reserve-memory-for-initrd">Reserve memory for initrd</h2>
<p>In the next step after we reserved place for the kernel text and data is reserving place for the <a href="http://en.wikipedia.org/wiki/Initrd" target="_blank">initrd</a>. We will not see details about <code>initrd</code> in this post, you just may know that it is temporary root file system stored in memory and used by the kernel during its startup. The <code>early_reserve_initrd</code> function does all work. First of all this function gets the base address of the ram disk, its size and the end address with:</p>
<pre><code class="lang-C">u64 ramdisk_image = get_ramdisk_image();
u64 ramdisk_size  = get_ramdisk_size();
u64 ramdisk_end   = PAGE_ALIGN(ramdisk_image + ramdisk_size);
</code></pre>
<p>All of these parameters are taken from <code>boot_params</code>. If you have read the chapter about <a href="http://0xax.gitbooks.io/linux-insides/content/Booting/index.html" target="_blank">Linux Kernel Booting Process</a>, you must remember that we filled the <code>boot_params</code> structure during boot time. The kernel setup header contains a couple of fields which describes ramdisk, for example:</p>
<pre><code>Field name:    ramdisk_image
Type:        write (obligatory)
Offset/size:    0x218/4
Protocol:    2.00+

  The 32-bit linear address of the initial ramdisk or ramfs.  Leave at
  zero if there is no initial ramdisk/ramfs.
</code></pre><p>So we can get all the information that interests us from <code>boot_params</code>. For example let&apos;s look at <code>get_ramdisk_image</code>:</p>
<pre><code class="lang-C"><span class="hljs-keyword">static</span> u64 __<span class="hljs-function">init <span class="hljs-title">get_ramdisk_image</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
        u64 ramdisk_image = boot_params.hdr.ramdisk_image;

        ramdisk_image |= (u64)boot_params.ext_ramdisk_image &lt;&lt; <span class="hljs-number">32</span>;

        <span class="hljs-keyword">return</span> ramdisk_image;
}
</code></pre>
<p>Here we get the address of the ramdisk from the <code>boot_params</code> and shift left it on <code>32</code>. We need to do it because as you can read in the <a href="https://github.com/0xAX/linux/blob/master/Documentation/x86/zero-page.txt" target="_blank">Documentation/x86/zero-page.txt</a>:</p>
<pre><code>0C0/004    ALL    ext_ramdisk_image ramdisk_image high 32bits
</code></pre><p>So after shifting it on 32, we&apos;re getting a 64-bit address in <code>ramdisk_image</code> and we return it. <code>get_ramdisk_size</code> works on the same principle as <code>get_ramdisk_image</code>, but it used <code>ext_ramdisk_size</code> instead of <code>ext_ramdisk_image</code>. After we got ramdisk&apos;s size, base address and end address, we check that bootloader provided ramdisk with the:</p>
<pre><code class="lang-C"><span class="hljs-keyword">if</span> (!boot_params.hdr.type_of_loader ||
    !ramdisk_image || !ramdisk_size)
    <span class="hljs-keyword">return</span>;
</code></pre>
<p>and reserve memory block with the calculated addresses for the initial ramdisk in the end:</p>
<pre><code class="lang-C">memblock_reserve(ramdisk_image, ramdisk_end - ramdisk_image);
</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>It is the end of the fourth part about the Linux kernel initialization process. We started to dive in the kernel generic code from the <code>start_kernel</code> function in this part and stopped on the architecture-specific initialization in the <code>setup_arch</code>. In the next part we will continue with architecture-dependent initialization steps.</p>
<p>If you have any questions or suggestions write me a comment or ping me at <a href="https://twitter.com/0xAX" target="_blank">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me a PR to <a href="https://github.com/0xAX/linux-insides" target="_blank">linux-insides</a>.</strong></p>
<h2 id="links">Links</h2>
<ul>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html" target="_blank">GCC function attributes</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/this_cpu_ops.txt" target="_blank">this_cpu operations</a></li>
<li><a href="http://www.crashcourse.ca/wiki/index.php/Cpumask" target="_blank">cpumask</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt" target="_blank">lock validator</a></li>
<li><a href="http://en.wikipedia.org/wiki/Cgroups" target="_blank">cgroups</a></li>
<li><a href="http://en.wikipedia.org/wiki/Stack_buffer_overflow" target="_blank">stack buffer overflow</a></li>
<li><a href="http://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29" target="_blank">IRQs</a></li>
<li><a href="http://en.wikipedia.org/wiki/Initrd" target="_blank">initrd</a></li>
<li><a href="https://github.com/0xAX/linux-insides/blob/master/Initialization/linux-initialization-3.md" target="_blank">Previous part</a></li>
</ul>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="linux-initialization-3.html" class="navigation navigation-prev " aria-label="Previous page: Last preparations before the kernel entry point">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="linux-initialization-5.html" class="navigation navigation-next " aria-label="Next page: Continue architecture-specific boot-time initializations">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Kernel entry point","level":"1.3.4","depth":2,"next":{"title":"Continue architecture-specific boot-time initializations","level":"1.3.5","depth":2,"path":"Initialization/linux-initialization-5.md","ref":"Initialization/linux-initialization-5.md","articles":[]},"previous":{"title":"Last preparations before the kernel entry point","level":"1.3.3","depth":2,"path":"Initialization/linux-initialization-3.md","ref":"Initialization/linux-initialization-3.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["livereload"],"pluginsConfig":{"livereload":{},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"Initialization/linux-initialization-4.md","mtime":"2019-03-28T07:54:50.392Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2019-03-28T07:57:01.662Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-livereload/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

