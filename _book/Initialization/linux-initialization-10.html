
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>End of initialization Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../interrupts/" />
    
    
    <link rel="prev" href="linux-initialization-9.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        <li class="header">Summary</li>
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../Booting/">
            
                <a href="../Booting/">
            
                    
                    Booting
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../Booting/linux-bootstrap-1.html">
            
                <a href="../Booting/linux-bootstrap-1.html">
            
                    
                    From bootloader to kernel
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../Booting/linux-bootstrap-2.html">
            
                <a href="../Booting/linux-bootstrap-2.html">
            
                    
                    First steps in the kernel setup code
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../Booting/linux-bootstrap-3.html">
            
                <a href="../Booting/linux-bootstrap-3.html">
            
                    
                    Video mode initialization and transition to protected mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="../Booting/linux-bootstrap-4.html">
            
                <a href="../Booting/linux-bootstrap-4.html">
            
                    
                    Transition to 64-bit mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="../Booting/linux-bootstrap-5.html">
            
                <a href="../Booting/linux-bootstrap-5.html">
            
                    
                    Kernel decompression
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="./">
            
                <a href="./">
            
                    
                    Initialization
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="linux-initialization-1.html">
            
                <a href="linux-initialization-1.html">
            
                    
                    First steps in the kernel
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="linux-initialization-2.html">
            
                <a href="linux-initialization-2.html">
            
                    
                    Early interrupts handler
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="linux-initialization-3.html">
            
                <a href="linux-initialization-3.html">
            
                    
                    Last preparations before the kernel entry point
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="linux-initialization-4.html">
            
                <a href="linux-initialization-4.html">
            
                    
                    Kernel entry point
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="linux-initialization-5.html">
            
                <a href="linux-initialization-5.html">
            
                    
                    Continue architecture-specific boot-time initializations
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="linux-initialization-6.html">
            
                <a href="linux-initialization-6.html">
            
                    
                    Architecture-specific initializations, again...
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="linux-initialization-7.html">
            
                <a href="linux-initialization-7.html">
            
                    
                    End of the architecture-specific initializations, almost...
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="linux-initialization-8.html">
            
                <a href="linux-initialization-8.html">
            
                    
                    Scheduler initialization
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.9" data-path="linux-initialization-9.html">
            
                <a href="linux-initialization-9.html">
            
                    
                    RCU initialization
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.3.10" data-path="linux-initialization-10.html">
            
                <a href="linux-initialization-10.html">
            
                    
                    End of initialization
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../interrupts/">
            
                <a href="../interrupts/">
            
                    
                    Interrupts
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../interrupts/interrupts-1.html">
            
                <a href="../interrupts/interrupts-1.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../interrupts/interrupts-2.html">
            
                <a href="../interrupts/interrupts-2.html">
            
                    
                    Start to dive into interrupts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../interrupts/interrupts-3.html">
            
                <a href="../interrupts/interrupts-3.html">
            
                    
                    Interrupt handlers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="../interrupts/interrupts-4.html">
            
                <a href="../interrupts/interrupts-4.html">
            
                    
                    Initialization of non-early interrupt gates
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.5" data-path="../interrupts/interrupts-5.html">
            
                <a href="../interrupts/interrupts-5.html">
            
                    
                    Implementation of some exception handlers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.6" data-path="../interrupts/interrupts-6.html">
            
                <a href="../interrupts/interrupts-6.html">
            
                    
                    Handling Non-Maskable interrupts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.7" data-path="../interrupts/interrupts-7.html">
            
                <a href="../interrupts/interrupts-7.html">
            
                    
                    Dive into external hardware interrupts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.8" data-path="../interrupts/interrupts-8.html">
            
                <a href="../interrupts/interrupts-8.html">
            
                    
                    Initialization of external hardware interrupts structures
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.9" data-path="../interrupts/interrupts-9.html">
            
                <a href="../interrupts/interrupts-9.html">
            
                    
                    Softirq, Tasklets and Workqueues
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.10" data-path="../interrupts/interrupts-10.html">
            
                <a href="../interrupts/interrupts-10.html">
            
                    
                    Last part
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../SysCall/">
            
                <a href="../SysCall/">
            
                    
                    System calls
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../SysCall/syscall-1.html">
            
                <a href="../SysCall/syscall-1.html">
            
                    
                    Introduction to system calls
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="../SysCall/syscall-2.html">
            
                <a href="../SysCall/syscall-2.html">
            
                    
                    How the Linux kernel handles a system call
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="../SysCall/syscall-3.html">
            
                <a href="../SysCall/syscall-3.html">
            
                    
                    vsyscall and vDSO
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="../SysCall/syscall-4.html">
            
                <a href="../SysCall/syscall-4.html">
            
                    
                    How the Linux kernel runs a program
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.5" data-path="../SysCall/syscall-5.html">
            
                <a href="../SysCall/syscall-5.html">
            
                    
                    Implementation of the open system call
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../Timers/">
            
                <a href="../Timers/">
            
                    
                    Timers and time management
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../Timers/timers-1.html">
            
                <a href="../Timers/timers-1.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="../Timers/timers-2.html">
            
                <a href="../Timers/timers-2.html">
            
                    
                    Clocksource framework
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="../Timers/timers-3.html">
            
                <a href="../Timers/timers-3.html">
            
                    
                    The tick broadcast framework and dyntick
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="../Timers/timers-4.html">
            
                <a href="../Timers/timers-4.html">
            
                    
                    Introduction to timers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.5" data-path="../Timers/timers-5.html">
            
                <a href="../Timers/timers-5.html">
            
                    
                    Clockevents framework
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.6" data-path="../Timers/timers-6.html">
            
                <a href="../Timers/timers-6.html">
            
                    
                    x86 related clock sources
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.7" data-path="../Timers/timers-7.html">
            
                <a href="../Timers/timers-7.html">
            
                    
                    Time related system calls
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../SyncPrim/">
            
                <a href="../SyncPrim/">
            
                    
                    Synchronization primitives
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="../SyncPrim/sync-1.html">
            
                <a href="../SyncPrim/sync-1.html">
            
                    
                    Introduction to spinlocks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="../SyncPrim/sync-2.html">
            
                <a href="../SyncPrim/sync-2.html">
            
                    
                    Queued spinlocks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="../SyncPrim/sync-3.html">
            
                <a href="../SyncPrim/sync-3.html">
            
                    
                    Semaphores
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4" data-path="../SyncPrim/sync-4.html">
            
                <a href="../SyncPrim/sync-4.html">
            
                    
                    Mutex
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5" data-path="../SyncPrim/sync-5.html">
            
                <a href="../SyncPrim/sync-5.html">
            
                    
                    Reader/Writer semaphores
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.6" data-path="../SyncPrim/sync-6.html">
            
                <a href="../SyncPrim/sync-6.html">
            
                    
                    SeqLock
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.7" >
            
                <span>
            
                    
                    RCU
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.8" >
            
                <span>
            
                    
                    Lockdep
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../mm/">
            
                <a href="../mm/">
            
                    
                    Memory management
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="../mm/linux-mm-1.html">
            
                <a href="../mm/linux-mm-1.html">
            
                    
                    Memblock
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="../mm/linux-mm-2.html">
            
                <a href="../mm/linux-mm-2.html">
            
                    
                    Fixmaps and ioremap
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="../mm/linux-mm-3.html">
            
                <a href="../mm/linux-mm-3.html">
            
                    
                    kmemcheck
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="../Cgroups/">
            
                <a href="../Cgroups/">
            
                    
                    Cgroups
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="../Cgroups/cgroups1.html">
            
                <a href="../Cgroups/cgroups1.html">
            
                    
                    Introduction to Control Groups
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" >
            
                <span>
            
                    
                    SMP
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="../Concepts/">
            
                <a href="../Concepts/">
            
                    
                    Concepts
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.11.1" data-path="../Concepts/per-cpu.html">
            
                <a href="../Concepts/per-cpu.html">
            
                    
                    Per-CPU variables
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.2" data-path="../Concepts/cpumask.html">
            
                <a href="../Concepts/cpumask.html">
            
                    
                    Cpumasks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.3" data-path="../Concepts/initcall.html">
            
                <a href="../Concepts/initcall.html">
            
                    
                    The initcall mechanism
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="../DataStructures/">
            
                <a href="../DataStructures/">
            
                    
                    Data Structures in the Linux Kernel
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.12.1" data-path="../DataStructures/dlist.html">
            
                <a href="../DataStructures/dlist.html">
            
                    
                    Doubly linked list
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.2" data-path="../DataStructures/radix-tree.html">
            
                <a href="../DataStructures/radix-tree.html">
            
                    
                    Radix tree
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.3" data-path="../DataStructures/bitmap.html">
            
                <a href="../DataStructures/bitmap.html">
            
                    
                    Bit arrays
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="../Theory/">
            
                <a href="../Theory/">
            
                    
                    Theory
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.13.1" data-path="../Theory/Paging.html">
            
                <a href="../Theory/Paging.html">
            
                    
                    Paging
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.2" data-path="../Theory/ELF.html">
            
                <a href="../Theory/ELF.html">
            
                    
                    Elf64
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.3" data-path="../Theory/asm.html">
            
                <a href="../Theory/asm.html">
            
                    
                    Inline assembly
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.4" >
            
                <span>
            
                    
                    CPUID
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.5" >
            
                <span>
            
                    
                    MSR
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.14" >
            
                <span>
            
                    
                    Initial ram disk
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.14.1" >
            
                <span>
            
                    
                    initrd
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="../Misc/">
            
                <a href="../Misc/">
            
                    
                    Misc
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.15.1" data-path="../Misc/how_kernel_compiled.html">
            
                <a href="../Misc/how_kernel_compiled.html">
            
                    
                    How the kernel is compiled
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.2" data-path="../Misc/linkers.html">
            
                <a href="../Misc/linkers.html">
            
                    
                    Linkers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.3" data-path="../Misc/contribute.html">
            
                <a href="../Misc/contribute.html">
            
                    
                    Linux kernel development
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.4" data-path="../Misc/program_startup.html">
            
                <a href="../Misc/program_startup.html">
            
                    
                    Program startup process in userspace
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.5" >
            
                <span>
            
                    
                    Write and Submit your first Linux kernel Patch
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.6" >
            
                <span>
            
                    
                    Data types in the kernel
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="../KernelStructures/">
            
                <a href="../KernelStructures/">
            
                    
                    KernelStructures
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.16.1" data-path="../KernelStructures/idt.html">
            
                <a href="../KernelStructures/idt.html">
            
                    
                    IDT
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.17" data-path="../LINKS.html">
            
                <a href="../LINKS.html">
            
                    
                    Useful links
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.18" data-path="../contributors.html">
            
                <a href="../contributors.html">
            
                    
                    Contributors
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >End of initialization</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="kernel-initialization-part-10">Kernel initialization. Part 10.</h1>
<h1 id="end-of-the-linux-kernel-initialization-process">End of the linux kernel initialization process</h1>
<p>This is tenth part of the chapter about linux kernel <a href="http://0xax.gitbooks.io/linux-insides/content/Initialization/index.html" target="_blank">initialization process</a> and in the <a href="http://0xax.gitbooks.io/linux-insides/content/Initialization/linux-initialization-9.html" target="_blank">previous part</a> we saw the initialization of the <a href="http://en.wikipedia.org/wiki/Read-copy-update" target="_blank">RCU</a> and stopped on the call of the <code>acpi_early_init</code> function. This part will be the last part of the <a href="http://0xax.gitbooks.io/linux-insides/content/Initialization/index.html" target="_blank">Kernel initialization process</a> chapter, so let&apos;s finish it.</p>
<p>After the call of the <code>acpi_early_init</code> function from the <a href="https://github.com/torvalds/linux/blob/master/init/main.c" target="_blank">init/main.c</a>, we can see the following code:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_X86_ESPFIX64</span>
    init_espfix_bsp();
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
</code></pre>
<p>Here we can see the call of the <code>init_espfix_bsp</code> function which depends on the <code>CONFIG_X86_ESPFIX64</code> kernel configuration option. As we can understand from the function name, it does something with the stack. This function is defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/espfix_64.c" target="_blank">arch/x86/kernel/espfix_64.c</a> and prevents leaking of <code>31:16</code> bits of the <code>esp</code> register during returning to 16-bit stack. First of all we install <code>espfix</code> page upper directory into the kernel page directory in the <code>init_espfix_bs</code>:</p>
<pre><code class="lang-C">pgd_p = &amp;init_level4_pgt[pgd_index(ESPFIX_BASE_ADDR)];
pgd_populate(&amp;init_mm, pgd_p, (<span class="hljs-keyword">pud_t</span> *)espfix_pud_page);
</code></pre>
<p>Where <code>ESPFIX_BASE_ADDR</code> is:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PGDIR_SHIFT     39</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ESPFIX_PGD_ENTRY _AC(-2, UL)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ESPFIX_BASE_ADDR (ESPFIX_PGD_ENTRY &lt;&lt; PGDIR_SHIFT)</span>
</code></pre>
<p>Also we can find it in the <a href="https://github.com/torvalds/linux/blob/master/Documentation/x86/x86_64/mm.txt" target="_blank">Documentation/x86/x86_64/mm</a>:</p>
<pre><code>... unused hole ...
ffffff0000000000 - ffffff7fffffffff (=39 bits) %esp fixup stacks
... unused hole ...
</code></pre><p>After we&apos;ve filled page global directory with the <code>espfix</code> pud, the next step is call of the <code>init_espfix_random</code> and <code>init_espfix_ap</code> functions. The first function returns random locations for the <code>espfix</code> page and the second enables the <code>espfix</code> for the current CPU. After the <code>init_espfix_bsp</code> finished the work, we can see the call of the <code>thread_info_cache_init</code> function which defined in the <a href="https://github.com/torvalds/linux/blob/master/kernel/fork.c" target="_blank">kernel/fork.c</a> and allocates cache for the <code>thread_info</code> if <code>THREAD_SIZE</code> is less than <code>PAGE_SIZE</code>:</p>
<pre><code class="lang-C"><span class="hljs-meta"># <span class="hljs-meta-keyword">if</span> THREAD_SIZE &gt;= PAGE_SIZE</span>
...
...
...
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">thread_info_cache_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
        thread_info_cache = kmem_cache_create(<span class="hljs-string">&quot;thread_info&quot;</span>, THREAD_SIZE,
                                              THREAD_SIZE, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);
        BUG_ON(thread_info_cache == <span class="hljs-literal">NULL</span>);
}
...
...
...
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
</code></pre>
<p>As we already know the <code>PAGE_SIZE</code> is <code>(_AC(1,UL) &lt;&lt; PAGE_SHIFT)</code> or <code>4096</code> bytes and <code>THREAD_SIZE</code> is <code>(PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)</code> or <code>16384</code> bytes for the <code>x86_64</code>. The next function after the <code>thread_info_cache_init</code> is the <code>cred_init</code> from the <a href="https://github.com/torvalds/linux/blob/master/kernel/cred.c" target="_blank">kernel/cred.c</a>. This function just allocates cache for the credentials (like <code>uid</code>, <code>gid</code>, etc.):</p>
<pre><code class="lang-C"><span class="hljs-keyword">void</span> __<span class="hljs-function">init <span class="hljs-title">cred_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
         cred_jar = kmem_cache_create(<span class="hljs-string">&quot;cred_jar&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> cred),
                                     <span class="hljs-number">0</span>, SLAB_HWCACHE_ALIGN|SLAB_PANIC, <span class="hljs-literal">NULL</span>);
}
</code></pre>
<p>more about credentials you can read in the <a href="https://github.com/torvalds/linux/blob/master/Documentation/security/credentials.txt" target="_blank">Documentation/security/credentials.txt</a>. Next step is the <code>fork_init</code> function from the <a href="https://github.com/torvalds/linux/blob/master/kernel/fork.c" target="_blank">kernel/fork.c</a>. The <code>fork_init</code> function allocates cache for the <code>task_struct</code>. Let&apos;s look on the implementation of the <code>fork_init</code>. First of all we can see definitions of the <code>ARCH_MIN_TASKALIGN</code> macro and creation of a slab where task_structs will be allocated:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> CONFIG_ARCH_TASK_STRUCT_ALLOCATOR</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> ARCH_MIN_TASKALIGN</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ARCH_MIN_TASKALIGN      L1_CACHE_BYTES</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
        task_struct_cachep =
                kmem_cache_create(<span class="hljs-string">&quot;task_struct&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> task_struct),
                        ARCH_MIN_TASKALIGN, SLAB_PANIC | SLAB_NOTRACK, <span class="hljs-literal">NULL</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
</code></pre>
<p>As we can see this code depends on the <code>CONFIG_ARCH_TASK_STRUCT_ACLLOCATOR</code> kernel configuration option. This configuration option shows the presence of the <code>alloc_task_struct</code> for the given architecture. As <code>x86_64</code> has no <code>alloc_task_struct</code> function, this code will not work and even will not be compiled on the <code>x86_64</code>.</p>
<h2 id="allocating-cache-for-init-task">Allocating cache for init task</h2>
<p>After this we can see the call of the <code>arch_task_cache_init</code> function in the <code>fork_init</code>:</p>
<pre><code class="lang-C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arch_task_cache_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
        task_xstate_cachep =
                kmem_cache_create(<span class="hljs-string">&quot;task_xstate&quot;</span>, xstate_size,
                                  __alignof__(<span class="hljs-keyword">union</span> thread_xstate),
                                  SLAB_PANIC | SLAB_NOTRACK, <span class="hljs-literal">NULL</span>);
        setup_xstate_comp();
}
</code></pre>
<p>The <code>arch_task_cache_init</code> does initialization of the architecture-specific caches. In our case it is <code>x86_64</code>, so as we can see, the <code>arch_task_cache_init</code> allocates cache for the <code>task_xstate</code> which represents <a href="http://en.wikipedia.org/wiki/Floating-point_unit" target="_blank">FPU</a> state and sets up offsets and sizes of all extended states in <a href="http://www.felixcloutier.com/x86/XSAVES.html" target="_blank">xsave</a> area with the call of the <code>setup_xstate_comp</code> function. After the <code>arch_task_cache_init</code> we calculate default maximum number of threads with the:</p>
<pre><code class="lang-C">set_max_threads(MAX_THREADS);
</code></pre>
<p>where default maximum number of threads is:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FUTEX_TID_MASK  0x3fffffff</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_THREADS     FUTEX_TID_MASK</span>
</code></pre>
<p>In the end of the <code>fork_init</code> function we initialize <a href="http://www.win.tue.nl/~aeb/linux/lk/lk-5.html" target="_blank">signal</a> handler:</p>
<pre><code class="lang-C">init_task.signal-&gt;rlim[RLIMIT_NPROC].rlim_cur = max_threads/<span class="hljs-number">2</span>;
init_task.signal-&gt;rlim[RLIMIT_NPROC].rlim_max = max_threads/<span class="hljs-number">2</span>;
init_task.signal-&gt;rlim[RLIMIT_SIGPENDING] =
        init_task.signal-&gt;rlim[RLIMIT_NPROC];
</code></pre>
<p>As we know the <code>init_task</code> is an instance of the <code>task_struct</code> structure, so it contains <code>signal</code> field which represents signal handler. It has following type <code>struct signal_struct</code>. On the first two lines we can see setting of the current and maximum limit of the <code>resource limits</code>. Every process has an associated set of resource limits. These limits specify amount of resources which current process can use. Here <code>rlim</code> is resource control limit and presented by the:</p>
<pre><code class="lang-C"><span class="hljs-keyword">struct</span> rlimit {
        <span class="hljs-keyword">__kernel_ulong_t</span>        rlim_cur;
        <span class="hljs-keyword">__kernel_ulong_t</span>        rlim_max;
};
</code></pre>
<p>structure from the <a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/resource.h" target="_blank">include/uapi/linux/resource.h</a>. In our case the resource is the <code>RLIMIT_NPROC</code> which is the maximum number of processes that user can own and <code>RLIMIT_SIGPENDING</code> - the maximum number of pending signals. We can see it in the:</p>
<pre><code class="lang-C">cat /proc/self/limits
Limit                     Soft Limit           Hard Limit           Units     
...
...
...
Max processes             <span class="hljs-number">63815</span>                <span class="hljs-number">63815</span>                processes 
Max pending signals       <span class="hljs-number">63815</span>                <span class="hljs-number">63815</span>                signals   
...
...
...
</code></pre>
<h2 id="initialization-of-the-caches">Initialization of the caches</h2>
<p>The next function after the <code>fork_init</code> is the <code>proc_caches_init</code> from the <a href="https://github.com/torvalds/linux/blob/master/kernel/fork.c" target="_blank">kernel/fork.c</a>. This function allocates caches for the memory descriptors (or <code>mm_struct</code> structure). At the beginning of the <code>proc_caches_init</code> we can see allocation of the different <a href="http://en.wikipedia.org/wiki/Slab_allocation" target="_blank">SLAB</a> caches with the call of the <code>kmem_cache_create</code>:</p>
<ul>
<li><code>sighand_cachep</code> - manage information about installed signal handlers;</li>
<li><code>signal_cachep</code> - manage information about process signal descriptor; </li>
<li><code>files_cachep</code> - manage information about opened files;</li>
<li><code>fs_cachep</code> - manage filesystem information.</li>
</ul>
<p>After this we allocate <code>SLAB</code> cache for the <code>mm_struct</code> structures:</p>
<pre><code class="lang-C">mm_cachep = kmem_cache_create(<span class="hljs-string">&quot;mm_struct&quot;</span>,
                         <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> mm_struct), ARCH_MIN_MMSTRUCT_ALIGN,
                         SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, <span class="hljs-literal">NULL</span>);
</code></pre>
<p>After this we allocate <code>SLAB</code> cache for the important <code>vm_area_struct</code> which used by the kernel to manage virtual memory space:</p>
<pre><code class="lang-C">vm_area_cachep = KMEM_CACHE(vm_area_struct, SLAB_PANIC);
</code></pre>
<p>Note, that we use <code>KMEM_CACHE</code> macro here instead of the <code>kmem_cache_create</code>. This macro is defined in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/slab.h" target="_blank">include/linux/slab.h</a> and just expands to the <code>kmem_cache_create</code> call:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KMEM_CACHE(__struct, __flags) kmem_cache_create(#__struct,\
                sizeof(struct __struct), __alignof__(struct __struct),\
                (__flags), NULL)</span>
</code></pre>
<p>The <code>KMEM_CACHE</code> has one difference from <code>kmem_cache_create</code>. Take a look on <code>__alignof__</code> operator. The <code>KMEM_CACHE</code> macro aligns <code>SLAB</code> to the size of the given structure, but <code>kmem_cache_create</code> uses given value to align space. After this we can see the call of the <code>mmap_init</code> and <code>nsproxy_cache_init</code> functions. The first function initializes virtual memory area <code>SLAB</code> and the second function initializes <code>SLAB</code> for namespaces.</p>
<p>The next function after the <code>proc_caches_init</code> is <code>buffer_init</code>. This function is defined in the <a href="https://github.com/torvalds/linux/blob/master/fs/buffer.c" target="_blank">fs/buffer.c</a> source code file and allocate cache for the <code>buffer_head</code>. The <code>buffer_head</code> is a special structure which defined in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/buffer_head.h" target="_blank">include/linux/buffer_head.h</a> and used for managing buffers. In the start of the <code>buffer_init</code> function we allocate cache for the <code>struct buffer_head</code> structures with the call of the <code>kmem_cache_create</code> function as we did in the previous functions. And calculate the maximum size of the buffers in memory with:</p>
<pre><code class="lang-C">nrpages = (nr_free_buffer_pages() * <span class="hljs-number">10</span>) / <span class="hljs-number">100</span>;
max_buffer_heads = nrpages * (PAGE_SIZE / <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> buffer_head));
</code></pre>
<p>which will be equal to the <code>10%</code> of the <code>ZONE_NORMAL</code> (all RAM from the 4GB on the <code>x86_64</code>). The next function after the <code>buffer_init</code> is - <code>vfs_caches_init</code>. This function allocates <code>SLAB</code> caches and hashtable for different <a href="http://en.wikipedia.org/wiki/Virtual_file_system" target="_blank">VFS</a> caches. We already saw the <code>vfs_caches_init_early</code> function in the eighth part of the linux kernel <a href="http://0xax.gitbooks.io/linux-insides/content/Initialization/linux-initialization-8.html" target="_blank">initialization process</a> which initialized caches for <code>dcache</code> (or directory-cache) and <a href="http://en.wikipedia.org/wiki/Inode" target="_blank">inode</a> cache. The <code>vfs_caches_init</code> function makes post-early initialization of the <code>dcache</code> and <code>inode</code> caches, private data cache, hash tables for the mount points, etc. More details about <a href="http://en.wikipedia.org/wiki/Virtual_file_system" target="_blank">VFS</a> will be described in the separate part. After this we can see <code>signals_init</code> function. This function is defined in the <a href="https://github.com/torvalds/linux/blob/master/kernel/signal.c" target="_blank">kernel/signal.c</a> and allocates a cache for the <code>sigqueue</code> structures which represents queue of the real time signals. The next function is <code>page_writeback_init</code>. This function initializes the ratio for the dirty pages. Every low-level page entry contains the <code>dirty</code> bit which indicates whether a page has been written to after been loaded into memory.</p>
<h2 id="creation-of-the-root-for-the-procfs">Creation of the root for the procfs</h2>
<p>After all of this preparations we need to create the root for the <a href="http://en.wikipedia.org/wiki/Procfs" target="_blank">proc</a> filesystem. We will do it with the call of the <code>proc_root_init</code> function from the <a href="https://github.com/torvalds/linux/blob/master/fs/proc/root.c" target="_blank">fs/proc/root.c</a>. At the start of the <code>proc_root_init</code> function we allocate the cache for the inodes and register a new filesystem in the system with the:</p>
<pre><code class="lang-C">err = register_filesystem(&amp;proc_fs_type);
      <span class="hljs-keyword">if</span> (err)
                <span class="hljs-keyword">return</span>;
</code></pre>
<p>As I wrote above we will not dive into details about <a href="http://en.wikipedia.org/wiki/Virtual_file_system" target="_blank">VFS</a> and different filesystems in this chapter, but will see it in the chapter about the <code>VFS</code>. After we&apos;ve registered a new filesystem in our system, we call the <code>proc_self_init</code> function from the <a href="https://github.com/torvalds/linux/blob/master/fs/proc/self.c" target="_blank">fs/proc/self.c</a> and this function allocates <code>inode</code> number for the <code>self</code> (<code>/proc/self</code> directory refers to the process accessing the <code>/proc</code> filesystem). The next step after the <code>proc_self_init</code> is <code>proc_setup_thread_self</code> which setups the <code>/proc/thread-self</code> directory which contains information about current thread. After this we create <code>/proc/self/mounts</code> symlink which will contains mount points with the call of the</p>
<pre><code class="lang-C">proc_symlink(<span class="hljs-string">&quot;mounts&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;self/mounts&quot;</span>);
</code></pre>
<p>and a couple of directories depends on the different configuration options:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_SYSVIPC</span>
        proc_mkdir(<span class="hljs-string">&quot;sysvipc&quot;</span>, <span class="hljs-literal">NULL</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
        proc_mkdir(<span class="hljs-string">&quot;fs&quot;</span>, <span class="hljs-literal">NULL</span>);
        proc_mkdir(<span class="hljs-string">&quot;driver&quot;</span>, <span class="hljs-literal">NULL</span>);
        proc_mkdir(<span class="hljs-string">&quot;fs/nfsd&quot;</span>, <span class="hljs-literal">NULL</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE)</span>
        proc_mkdir(<span class="hljs-string">&quot;openprom&quot;</span>, <span class="hljs-literal">NULL</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
        proc_mkdir(<span class="hljs-string">&quot;bus&quot;</span>, <span class="hljs-literal">NULL</span>);
        ...
        ...
        ...
        <span class="hljs-keyword">if</span> (!proc_mkdir(<span class="hljs-string">&quot;tty&quot;</span>, <span class="hljs-literal">NULL</span>))
                 <span class="hljs-keyword">return</span>;
        proc_mkdir(<span class="hljs-string">&quot;tty/ldisc&quot;</span>, <span class="hljs-literal">NULL</span>);
        ...
        ...
        ...
</code></pre>
<p>In the end of the <code>proc_root_init</code> we call the <code>proc_sys_init</code> function which creates <code>/proc/sys</code> directory and initializes the <a href="http://en.wikipedia.org/wiki/Sysctl" target="_blank">Sysctl</a>.</p>
<p>It is the end of <code>start_kernel</code> function. I did not describe all functions which are called in the <code>start_kernel</code>. I skipped them, because they are not important for the generic kernel initialization stuff and depend on only different kernel configurations. They are <code>taskstats_init_early</code> which exports per-task statistic to the user-space, <code>delayacct_init</code> - initializes per-task delay accounting, <code>key_init</code> and <code>security_init</code> initialize different security stuff, <code>check_bugs</code> - fix some architecture-dependent bugs, <code>ftrace_init</code> function executes initialization of the <a href="https://www.kernel.org/doc/Documentation/trace/ftrace.txt" target="_blank">ftrace</a>, <code>cgroup_init</code> makes initialization of the rest of the <a href="http://en.wikipedia.org/wiki/Cgroups" target="_blank">cgroup</a> subsystem,etc. Many of these parts and subsystems will be described in the other chapters.</p>
<p>That&apos;s all. Finally we have passed through the long-long <code>start_kernel</code> function. But it is not the end of the linux kernel initialization process. We haven&apos;t run the first process yet. In the end of the <code>start_kernel</code> we can see the last call of the - <code>rest_init</code> function. Let&apos;s go ahead.</p>
<h2 id="first-steps-after-the-startkernel">First steps after the start_kernel</h2>
<p>The <code>rest_init</code> function is defined in the same source code file as <code>start_kernel</code> function, and this file is <a href="https://github.com/torvalds/linux/blob/master/init/main.c" target="_blank">init/main.c</a>. In the beginning of the <code>rest_init</code> we can see call of the two following functions:</p>
<pre><code class="lang-C">    rcu_scheduler_starting();
    smpboot_thread_init();
</code></pre>
<p>The first <code>rcu_scheduler_starting</code> makes <a href="http://en.wikipedia.org/wiki/Read-copy-update" target="_blank">RCU</a> scheduler active and the second <code>smpboot_thread_init</code> registers the <code>smpboot_thread_notifier</code> CPU notifier (more about it you can read in the <a href="https://www.kernel.org/doc/Documentation/cpu-hotplug.txt" target="_blank">CPU hotplug documentation</a>. After this we can see the following calls:</p>
<pre><code class="lang-C">kernel_thread(kernel_init, <span class="hljs-literal">NULL</span>, CLONE_FS);
pid = kernel_thread(kthreadd, <span class="hljs-literal">NULL</span>, CLONE_FS | CLONE_FILES);
</code></pre>
<p>Here the <code>kernel_thread</code> function (defined in the <a href="https://github.com/torvalds/linux/blob/master/kernel/fork.c" target="_blank">kernel/fork.c</a>) creates new kernel thread.As we can see the <code>kernel_thread</code> function takes three arguments:</p>
<ul>
<li>Function which will be executed in a new thread;</li>
<li>Parameter for the <code>kernel_init</code> function;</li>
<li>Flags.</li>
</ul>
<p>We will not dive into details about <code>kernel_thread</code> implementation (we will see it in the chapter which describe scheduler, just need to say that <code>kernel_thread</code> invokes <a href="http://www.tutorialspoint.com/unix_system_calls/clone.htm" target="_blank">clone</a>). Now we only need to know that we create new kernel thread with <code>kernel_thread</code> function, parent and child of the thread will use shared information about filesystem and it will start to execute <code>kernel_init</code> function. A kernel thread differs from a user thread that it runs in kernel mode. So with these two <code>kernel_thread</code> calls we create two new kernel threads with the <code>PID = 1</code> for <code>init</code> process and <code>PID = 2</code> for <code>kthreadd</code>. We already know what is <code>init</code> process. Let&apos;s look on the <code>kthreadd</code>. It is a special kernel thread which manages and helps different parts of the kernel to create another kernel thread. We can see it in the output of the <code>ps</code> util:</p>
<pre><code class="lang-C">$ ps -ef | grep kthread
root         <span class="hljs-number">2</span>     <span class="hljs-number">0</span>  <span class="hljs-number">0</span> Jan11 ?        <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> [kthreadd]
</code></pre>
<p>Let&apos;s postpone <code>kernel_init</code> and <code>kthreadd</code> for now and go ahead in the <code>rest_init</code>. In the next step after we have created two new kernel threads we can see the following code:</p>
<pre><code class="lang-C">    rcu_read_lock();
    kthreadd_task = find_task_by_pid_ns(pid, &amp;init_pid_ns);
    rcu_read_unlock();
</code></pre>
<p>The first <code>rcu_read_lock</code> function marks the beginning of an <a href="http://en.wikipedia.org/wiki/Read-copy-update" target="_blank">RCU</a> read-side critical section and the <code>rcu_read_unlock</code> marks the end of an RCU read-side critical section. We call these functions because we need to protect the <code>find_task_by_pid_ns</code>. The <code>find_task_by_pid_ns</code> returns pointer to the <code>task_struct</code> by the given pid. So, here we are getting the pointer to the <code>task_struct</code> for <code>PID = 2</code> (we got it after <code>kthreadd</code> creation with the <code>kernel_thread</code>). In the next step we call <code>complete</code> function</p>
<pre><code class="lang-C">complete(&amp;kthreadd_done);
</code></pre>
<p>and pass address of the <code>kthreadd_done</code>. The <code>kthreadd_done</code> defined as</p>
<pre><code class="lang-C"><span class="hljs-keyword">static</span> __<span class="hljs-function">initdata <span class="hljs-title">DECLARE_COMPLETION</span><span class="hljs-params">(kthreadd_done)</span></span>;
</code></pre>
<p>where <code>DECLARE_COMPLETION</code> macro defined as:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DECLARE_COMPLETION(work) \
         struct completion work = COMPLETION_INITIALIZER(work)</span>
</code></pre>
<p>and expands to the definition of the <code>completion</code> structure. This structure is defined in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/completion.h" target="_blank">include/linux/completion.h</a> and presents <code>completions</code> concept. Completions is a code synchronization mechanism which provides race-free solution for the threads that must wait for some process to have reached a point or a specific state. Using completions consists of three parts: The first is definition of the <code>complete</code> structure and we did it with the <code>DECLARE_COMPLETION</code>. The second is call of the <code>wait_for_completion</code>. After the call of this function, a thread which called it will not continue to execute and will wait while other thread did not call <code>complete</code> function. Note that we call <code>wait_for_completion</code> with the <code>kthreadd_done</code> in the beginning of the <code>kernel_init_freeable</code>:</p>
<pre><code class="lang-C">wait_for_completion(&amp;kthreadd_done);
</code></pre>
<p>And the last step is to call <code>complete</code> function as we saw it above. After this the <code>kernel_init_freeable</code> function will not be executed while <code>kthreadd</code> thread will not be set. After the <code>kthreadd</code> was set, we can see three following functions in the <code>rest_init</code>:</p>
<pre><code class="lang-C">    init_idle_bootup_task(current);
    schedule_preempt_disabled();
    cpu_startup_entry(CPUHP_ONLINE);
</code></pre>
<p>The first <code>init_idle_bootup_task</code> function from the <a href="https://github.com/torvalds/linux/blob/master/kernel/sched/core.c" target="_blank">kernel/sched/core.c</a> sets the Scheduling class for the current process (<code>idle</code> class in our case):</p>
<pre><code class="lang-C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_idle_bootup_task</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *idle)</span>
</span>{
         idle-&gt;sched_class = &amp;idle_sched_class;
}
</code></pre>
<p>where <code>idle</code> class is a low task priority and tasks can be run only when the processor doesn&apos;t have anything to run besides this tasks. The second function <code>schedule_preempt_disabled</code> disables preempt in <code>idle</code> tasks. And the third function <code>cpu_startup_entry</code> is defined in the <a href="https://github.com/torvalds/linux/blob/master/sched/idle.c" target="_blank">kernel/sched/idle.c</a> and calls <code>cpu_idle_loop</code> from the <a href="https://github.com/torvalds/linux/blob/master/sched/idle.c" target="_blank">kernel/sched/idle.c</a>. The <code>cpu_idle_loop</code> function works as process with <code>PID = 0</code> and works in the background. Main purpose of the <code>cpu_idle_loop</code> is to consume the idle CPU cycles. When there is no process to run, this process starts to work. We have one process with <code>idle</code> scheduling class (we just set the <code>current</code> task to the <code>idle</code> with the call of the <code>init_idle_bootup_task</code> function), so the <code>idle</code> thread does not do useful work but just checks if there is an active task to switch to: </p>
<pre><code class="lang-C"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cpu_idle_loop</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
        ...
        ...
        ...
        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
                <span class="hljs-keyword">while</span> (!need_resched()) {
                ...
                ...
                ...
                }
        ...
        }
</code></pre>
<p>More about it will be in the chapter about scheduler. So for this moment the <code>start_kernel</code> calls the <code>rest_init</code> function which spawns an <code>init</code> (<code>kernel_init</code> function) process and become <code>idle</code> process itself. Now is time to look on the <code>kernel_init</code>. Execution of the <code>kernel_init</code> function starts from the call of the <code>kernel_init_freeable</code> function. The <code>kernel_init_freeable</code> function first of all waits for the completion of the <code>kthreadd</code> setup. I already wrote about it above:</p>
<pre><code class="lang-C">wait_for_completion(&amp;kthreadd_done);
</code></pre>
<p>After this we set <code>gfp_allowed_mask</code> to <code>__GFP_BITS_MASK</code> which means that system is already running, set allowed <a href="https://www.kernel.org/doc/Documentation/cgroups/cpusets.txt" target="_blank">cpus/mems</a> to all CPUs and <a href="http://en.wikipedia.org/wiki/Non-uniform_memory_access" target="_blank">NUMA</a> nodes with the <code>set_mems_allowed</code> function, allow <code>init</code> process to run on any CPU with the <code>set_cpus_allowed_ptr</code>, set pid for the <code>cad</code> or <code>Ctrl-Alt-Delete</code>, do preparation for booting of the other CPUs with the call of the <code>smp_prepare_cpus</code>, call early <a href="http://kernelnewbies.org/Documents/InitcallMechanism" target="_blank">initcalls</a> with the <code>do_pre_smp_initcalls</code>, initialize <code>SMP</code> with the <code>smp_init</code> and initialize <a href="https://www.kernel.org/doc/Documentation/lockup-watchdogs.txt" target="_blank">lockup_detector</a> with the call of the <code>lockup_detector_init</code> and initialize scheduler with the <code>sched_init_smp</code>.</p>
<p>After this we can see the call of the following functions - <code>do_basic_setup</code>. Before we will call the <code>do_basic_setup</code> function, our kernel already initialized for this moment. As comment says:</p>
<pre><code>Now we can finally start doing some real work..
</code></pre><p>The <code>do_basic_setup</code> will reinitialize <a href="https://www.kernel.org/doc/Documentation/cgroups/cpusets.txt" target="_blank">cpuset</a> to the active CPUs, initialize the <code>khelper</code> - which is a kernel thread which used for making calls out to userspace from within the kernel, initialize <a href="http://en.wikipedia.org/wiki/Tmpfs" target="_blank">tmpfs</a>, initialize <code>drivers</code> subsystem, enable the user-mode helper <code>workqueue</code>  and make post-early call of the <code>initcalls</code>. We can see opening of the <code>dev/console</code> and dup twice file descriptors from <code>0</code> to <code>2</code> after the <code>do_basic_setup</code>:</p>
<pre><code class="lang-C"><span class="hljs-keyword">if</span> (sys_open((<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> __user *) <span class="hljs-string">&quot;/dev/console&quot;</span>, O_RDWR, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>)
    pr_err(<span class="hljs-string">&quot;Warning: unable to open an initial console.\n&quot;</span>);

(<span class="hljs-keyword">void</span>) sys_dup(<span class="hljs-number">0</span>);
(<span class="hljs-keyword">void</span>) sys_dup(<span class="hljs-number">0</span>);
</code></pre>
<p>We are using two system calls here <code>sys_open</code> and <code>sys_dup</code>. In the next chapters we will see explanation and implementation of the different system calls. After we opened initial console, we check that <code>rdinit=</code> option was passed to the kernel command line or set default path of the ramdisk:</p>
<pre><code class="lang-C"><span class="hljs-keyword">if</span> (!ramdisk_execute_command)
    ramdisk_execute_command = <span class="hljs-string">&quot;/init&quot;</span>;
</code></pre>
<p>Check user&apos;s permissions for the <code>ramdisk</code> and call the <code>prepare_namespace</code> function from the <a href="https://github.com/torvalds/linux/blob/master/init/do_mounts.c" target="_blank">init/do_mounts.c</a> which checks and mounts the <a href="http://en.wikipedia.org/wiki/Initrd" target="_blank">initrd</a>:</p>
<pre><code class="lang-C"><span class="hljs-keyword">if</span> (sys_access((<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> __user *) ramdisk_execute_command, <span class="hljs-number">0</span>) != <span class="hljs-number">0</span>) {
    ramdisk_execute_command = <span class="hljs-literal">NULL</span>;
    prepare_namespace();
}
</code></pre>
<p>This is the end of the <code>kernel_init_freeable</code> function and we need return to the <code>kernel_init</code>. The next step after the <code>kernel_init_freeable</code> finished its execution is the <code>async_synchronize_full</code>. This function waits until all asynchronous function calls have been done and after it we will call the <code>free_initmem</code> which will release all memory occupied by the initialization stuff which located between <code>__init_begin</code> and <code>__init_end</code>. After this we protect <code>.rodata</code> with the <code>mark_rodata_ro</code> and update state of the system from the <code>SYSTEM_BOOTING</code> to the</p>
<pre><code class="lang-C">system_state = SYSTEM_RUNNING;
</code></pre>
<p>And tries to run the <code>init</code> process:</p>
<pre><code class="lang-C"><span class="hljs-keyword">if</span> (ramdisk_execute_command) {
    ret = run_init_process(ramdisk_execute_command);
    <span class="hljs-keyword">if</span> (!ret)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    pr_err(<span class="hljs-string">&quot;Failed to execute %s (error %d)\n&quot;</span>,
           ramdisk_execute_command, ret);
}
</code></pre>
<p>First of all it checks the <code>ramdisk_execute_command</code> which we set in the <code>kernel_init_freeable</code> function and it will be equal to the value of the <code>rdinit=</code> kernel command line parameters or <code>/init</code> by default. The <code>run_init_process</code> function fills the first element of the <code>argv_init</code> array:</p>
<pre><code class="lang-C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *argv_init[MAX_INIT_ARGS+<span class="hljs-number">2</span>] = { <span class="hljs-string">&quot;init&quot;</span>, <span class="hljs-literal">NULL</span>, };
</code></pre>
<p>which represents arguments of the <code>init</code> program and call <code>do_execve</code> function:</p>
<pre><code class="lang-C">argv_init[<span class="hljs-number">0</span>] = init_filename;
<span class="hljs-keyword">return</span> do_execve(getname_kernel(init_filename),
    (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> __user *<span class="hljs-keyword">const</span> __user *)argv_init,
    (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> __user *<span class="hljs-keyword">const</span> __user *)envp_init);
</code></pre>
<p>The <code>do_execve</code> function is defined in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/sched.h" target="_blank">include/linux/sched.h</a> and runs program with the given file name and arguments. If we did not pass <code>rdinit=</code> option to the kernel command line, kernel starts to check the <code>execute_command</code> which is equal to value of the <code>init=</code> kernel command line parameter:</p>
<pre><code class="lang-C">    <span class="hljs-keyword">if</span> (execute_command) {
        ret = run_init_process(execute_command);
        <span class="hljs-keyword">if</span> (!ret)
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        panic(<span class="hljs-string">&quot;Requested init %s failed (error %d).&quot;</span>,
              execute_command, ret);
    }
</code></pre>
<p>If we did not pass <code>init=</code> kernel command line parameter either, kernel tries to run one of the following executable files: </p>
<pre><code class="lang-C"><span class="hljs-keyword">if</span> (!try_to_run_init_process(<span class="hljs-string">&quot;/sbin/init&quot;</span>) ||
    !try_to_run_init_process(<span class="hljs-string">&quot;/etc/init&quot;</span>) ||
    !try_to_run_init_process(<span class="hljs-string">&quot;/bin/init&quot;</span>) ||
    !try_to_run_init_process(<span class="hljs-string">&quot;/bin/sh&quot;</span>))
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</code></pre>
<p>Otherwise we finish with <a href="http://en.wikipedia.org/wiki/Kernel_panic" target="_blank">panic</a>:</p>
<pre><code class="lang-C">panic(<span class="hljs-string">&quot;No working init found.  Try passing init= option to kernel. &quot;</span>
      <span class="hljs-string">&quot;See Linux Documentation/init.txt for guidance.&quot;</span>);
</code></pre>
<p>That&apos;s all! Linux kernel initialization process is finished!</p>
<h2 id="conclusion">Conclusion</h2>
<p>It is the end of the tenth part about the linux kernel <a href="http://0xax.gitbooks.io/linux-insides/content/Initialization/index.html" target="_blank">initialization process</a>. It is not only the <code>tenth</code> part, but also is the last part which describes initialization of the linux kernel. As I wrote in the first <a href="http://0xax.gitbooks.io/linux-insides/content/Initialization/linux-initialization-1.html" target="_blank">part</a> of this chapter, we will go through all steps of the kernel initialization and we did it. We started at the first architecture-independent function - <code>start_kernel</code> and finished with the launch of the first <code>init</code> process in the our system. I skipped details about different subsystem of the kernel, for example I almost did not cover scheduler, interrupts, exception handling, etc. From the next part we will start to dive to the different kernel subsystems. Hope it will be interesting.</p>
<p>If you have any questions or suggestions write me a comment or ping me at <a href="https://twitter.com/0xAX" target="_blank">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides" target="_blank">linux-insides</a>.</strong></p>
<h2 id="links">Links</h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Slab_allocation" target="_blank">SLAB</a></li>
<li><a href="http://www.felixcloutier.com/x86/XSAVES.html" target="_blank">xsave</a></li>
<li><a href="http://en.wikipedia.org/wiki/Floating-point_unit" target="_blank">FPU</a></li>
<li><a href="https://github.com/torvalds/linux/blob/master/Documentation/security/credentials.txt" target="_blank">Documentation/security/credentials.txt</a></li>
<li><a href="https://github.com/torvalds/linux/blob/master/Documentation/x86/x86_64/mm.txt" target="_blank">Documentation/x86/x86_64/mm</a></li>
<li><a href="http://en.wikipedia.org/wiki/Read-copy-update" target="_blank">RCU</a></li>
<li><a href="http://en.wikipedia.org/wiki/Virtual_file_system" target="_blank">VFS</a></li>
<li><a href="http://en.wikipedia.org/wiki/Inode" target="_blank">inode</a></li>
<li><a href="http://en.wikipedia.org/wiki/Procfs" target="_blank">proc</a></li>
<li><a href="http://linux.die.net/man/5/proc" target="_blank">man proc</a></li>
<li><a href="http://en.wikipedia.org/wiki/Sysctl" target="_blank">Sysctl</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/trace/ftrace.txt" target="_blank">ftrace</a></li>
<li><a href="http://en.wikipedia.org/wiki/Cgroups" target="_blank">cgroup</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/cpu-hotplug.txt" target="_blank">CPU hotplug documentation</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/scheduler/completion.txt" target="_blank">completions - wait for completion handling</a></li>
<li><a href="http://en.wikipedia.org/wiki/Non-uniform_memory_access" target="_blank">NUMA</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/cgroups/cpusets.txt" target="_blank">cpus/mems</a></li>
<li><a href="http://kernelnewbies.org/Documents/InitcallMechanism" target="_blank">initcalls</a></li>
<li><a href="http://en.wikipedia.org/wiki/Tmpfs" target="_blank">Tmpfs</a></li>
<li><a href="http://en.wikipedia.org/wiki/Initrd" target="_blank">initrd</a></li>
<li><a href="http://en.wikipedia.org/wiki/Kernel_panic" target="_blank">panic</a></li>
<li><a href="http://0xax.gitbooks.io/linux-insides/content/Initialization/linux-initialization-9.html" target="_blank">Previous part</a></li>
</ul>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="linux-initialization-9.html" class="navigation navigation-prev " aria-label="Previous page: RCU initialization">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../interrupts/" class="navigation navigation-next " aria-label="Next page: Interrupts">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"End of initialization","level":"1.3.10","depth":2,"next":{"title":"Interrupts","level":"1.4","depth":1,"path":"interrupts/README.md","ref":"interrupts/README.md","articles":[{"title":"Introduction","level":"1.4.1","depth":2,"path":"interrupts/interrupts-1.md","ref":"interrupts/interrupts-1.md","articles":[]},{"title":"Start to dive into interrupts","level":"1.4.2","depth":2,"path":"interrupts/interrupts-2.md","ref":"interrupts/interrupts-2.md","articles":[]},{"title":"Interrupt handlers","level":"1.4.3","depth":2,"path":"interrupts/interrupts-3.md","ref":"interrupts/interrupts-3.md","articles":[]},{"title":"Initialization of non-early interrupt gates","level":"1.4.4","depth":2,"path":"interrupts/interrupts-4.md","ref":"interrupts/interrupts-4.md","articles":[]},{"title":"Implementation of some exception handlers","level":"1.4.5","depth":2,"path":"interrupts/interrupts-5.md","ref":"interrupts/interrupts-5.md","articles":[]},{"title":"Handling Non-Maskable interrupts","level":"1.4.6","depth":2,"path":"interrupts/interrupts-6.md","ref":"interrupts/interrupts-6.md","articles":[]},{"title":"Dive into external hardware interrupts","level":"1.4.7","depth":2,"path":"interrupts/interrupts-7.md","ref":"interrupts/interrupts-7.md","articles":[]},{"title":"Initialization of external hardware interrupts structures","level":"1.4.8","depth":2,"path":"interrupts/interrupts-8.md","ref":"interrupts/interrupts-8.md","articles":[]},{"title":"Softirq, Tasklets and Workqueues","level":"1.4.9","depth":2,"path":"interrupts/interrupts-9.md","ref":"interrupts/interrupts-9.md","articles":[]},{"title":"Last part","level":"1.4.10","depth":2,"path":"interrupts/interrupts-10.md","ref":"interrupts/interrupts-10.md","articles":[]}]},"previous":{"title":"RCU initialization","level":"1.3.9","depth":2,"path":"Initialization/linux-initialization-9.md","ref":"Initialization/linux-initialization-9.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["livereload"],"pluginsConfig":{"livereload":{},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"Initialization/linux-initialization-10.md","mtime":"2019-03-28T07:54:50.389Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2019-03-28T07:57:01.662Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-livereload/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

