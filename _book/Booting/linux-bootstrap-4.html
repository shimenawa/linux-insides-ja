
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Transition to 64-bit mode Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="linux-bootstrap-5.html" />
    
    
    <link rel="prev" href="linux-bootstrap-3.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        <li class="header">Summary</li>
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="./">
            
                <a href="./">
            
                    
                    Booting
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="linux-bootstrap-1.html">
            
                <a href="linux-bootstrap-1.html">
            
                    
                    From bootloader to kernel
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="linux-bootstrap-2.html">
            
                <a href="linux-bootstrap-2.html">
            
                    
                    First steps in the kernel setup code
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="linux-bootstrap-3.html">
            
                <a href="linux-bootstrap-3.html">
            
                    
                    Video mode initialization and transition to protected mode
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.2.4" data-path="linux-bootstrap-4.html">
            
                <a href="linux-bootstrap-4.html">
            
                    
                    Transition to 64-bit mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="linux-bootstrap-5.html">
            
                <a href="linux-bootstrap-5.html">
            
                    
                    Kernel decompression
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../Initialization/">
            
                <a href="../Initialization/">
            
                    
                    Initialization
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../Initialization/linux-initialization-1.html">
            
                <a href="../Initialization/linux-initialization-1.html">
            
                    
                    First steps in the kernel
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../Initialization/linux-initialization-2.html">
            
                <a href="../Initialization/linux-initialization-2.html">
            
                    
                    Early interrupts handler
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../Initialization/linux-initialization-3.html">
            
                <a href="../Initialization/linux-initialization-3.html">
            
                    
                    Last preparations before the kernel entry point
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../Initialization/linux-initialization-4.html">
            
                <a href="../Initialization/linux-initialization-4.html">
            
                    
                    Kernel entry point
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="../Initialization/linux-initialization-5.html">
            
                <a href="../Initialization/linux-initialization-5.html">
            
                    
                    Continue architecture-specific boot-time initializations
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="../Initialization/linux-initialization-6.html">
            
                <a href="../Initialization/linux-initialization-6.html">
            
                    
                    Architecture-specific initializations, again...
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="../Initialization/linux-initialization-7.html">
            
                <a href="../Initialization/linux-initialization-7.html">
            
                    
                    End of the architecture-specific initializations, almost...
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="../Initialization/linux-initialization-8.html">
            
                <a href="../Initialization/linux-initialization-8.html">
            
                    
                    Scheduler initialization
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.9" data-path="../Initialization/linux-initialization-9.html">
            
                <a href="../Initialization/linux-initialization-9.html">
            
                    
                    RCU initialization
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.10" data-path="../Initialization/linux-initialization-10.html">
            
                <a href="../Initialization/linux-initialization-10.html">
            
                    
                    End of initialization
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../interrupts/">
            
                <a href="../interrupts/">
            
                    
                    Interrupts
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../interrupts/interrupts-1.html">
            
                <a href="../interrupts/interrupts-1.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../interrupts/interrupts-2.html">
            
                <a href="../interrupts/interrupts-2.html">
            
                    
                    Start to dive into interrupts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../interrupts/interrupts-3.html">
            
                <a href="../interrupts/interrupts-3.html">
            
                    
                    Interrupt handlers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="../interrupts/interrupts-4.html">
            
                <a href="../interrupts/interrupts-4.html">
            
                    
                    Initialization of non-early interrupt gates
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.5" data-path="../interrupts/interrupts-5.html">
            
                <a href="../interrupts/interrupts-5.html">
            
                    
                    Implementation of some exception handlers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.6" data-path="../interrupts/interrupts-6.html">
            
                <a href="../interrupts/interrupts-6.html">
            
                    
                    Handling Non-Maskable interrupts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.7" data-path="../interrupts/interrupts-7.html">
            
                <a href="../interrupts/interrupts-7.html">
            
                    
                    Dive into external hardware interrupts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.8" data-path="../interrupts/interrupts-8.html">
            
                <a href="../interrupts/interrupts-8.html">
            
                    
                    Initialization of external hardware interrupts structures
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.9" data-path="../interrupts/interrupts-9.html">
            
                <a href="../interrupts/interrupts-9.html">
            
                    
                    Softirq, Tasklets and Workqueues
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.10" data-path="../interrupts/interrupts-10.html">
            
                <a href="../interrupts/interrupts-10.html">
            
                    
                    Last part
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../SysCall/">
            
                <a href="../SysCall/">
            
                    
                    System calls
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../SysCall/syscall-1.html">
            
                <a href="../SysCall/syscall-1.html">
            
                    
                    Introduction to system calls
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="../SysCall/syscall-2.html">
            
                <a href="../SysCall/syscall-2.html">
            
                    
                    How the Linux kernel handles a system call
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="../SysCall/syscall-3.html">
            
                <a href="../SysCall/syscall-3.html">
            
                    
                    vsyscall and vDSO
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="../SysCall/syscall-4.html">
            
                <a href="../SysCall/syscall-4.html">
            
                    
                    How the Linux kernel runs a program
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.5" data-path="../SysCall/syscall-5.html">
            
                <a href="../SysCall/syscall-5.html">
            
                    
                    Implementation of the open system call
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../Timers/">
            
                <a href="../Timers/">
            
                    
                    Timers and time management
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../Timers/timers-1.html">
            
                <a href="../Timers/timers-1.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="../Timers/timers-2.html">
            
                <a href="../Timers/timers-2.html">
            
                    
                    Clocksource framework
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="../Timers/timers-3.html">
            
                <a href="../Timers/timers-3.html">
            
                    
                    The tick broadcast framework and dyntick
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="../Timers/timers-4.html">
            
                <a href="../Timers/timers-4.html">
            
                    
                    Introduction to timers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.5" data-path="../Timers/timers-5.html">
            
                <a href="../Timers/timers-5.html">
            
                    
                    Clockevents framework
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.6" data-path="../Timers/timers-6.html">
            
                <a href="../Timers/timers-6.html">
            
                    
                    x86 related clock sources
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.7" data-path="../Timers/timers-7.html">
            
                <a href="../Timers/timers-7.html">
            
                    
                    Time related system calls
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../SyncPrim/">
            
                <a href="../SyncPrim/">
            
                    
                    Synchronization primitives
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="../SyncPrim/sync-1.html">
            
                <a href="../SyncPrim/sync-1.html">
            
                    
                    Introduction to spinlocks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="../SyncPrim/sync-2.html">
            
                <a href="../SyncPrim/sync-2.html">
            
                    
                    Queued spinlocks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="../SyncPrim/sync-3.html">
            
                <a href="../SyncPrim/sync-3.html">
            
                    
                    Semaphores
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4" data-path="../SyncPrim/sync-4.html">
            
                <a href="../SyncPrim/sync-4.html">
            
                    
                    Mutex
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5" data-path="../SyncPrim/sync-5.html">
            
                <a href="../SyncPrim/sync-5.html">
            
                    
                    Reader/Writer semaphores
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.6" data-path="../SyncPrim/sync-6.html">
            
                <a href="../SyncPrim/sync-6.html">
            
                    
                    SeqLock
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.7" >
            
                <span>
            
                    
                    RCU
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.8" >
            
                <span>
            
                    
                    Lockdep
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../mm/">
            
                <a href="../mm/">
            
                    
                    Memory management
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="../mm/linux-mm-1.html">
            
                <a href="../mm/linux-mm-1.html">
            
                    
                    Memblock
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="../mm/linux-mm-2.html">
            
                <a href="../mm/linux-mm-2.html">
            
                    
                    Fixmaps and ioremap
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="../mm/linux-mm-3.html">
            
                <a href="../mm/linux-mm-3.html">
            
                    
                    kmemcheck
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="../Cgroups/">
            
                <a href="../Cgroups/">
            
                    
                    Cgroups
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="../Cgroups/cgroups1.html">
            
                <a href="../Cgroups/cgroups1.html">
            
                    
                    Introduction to Control Groups
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" >
            
                <span>
            
                    
                    SMP
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="../Concepts/">
            
                <a href="../Concepts/">
            
                    
                    Concepts
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.11.1" data-path="../Concepts/per-cpu.html">
            
                <a href="../Concepts/per-cpu.html">
            
                    
                    Per-CPU variables
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.2" data-path="../Concepts/cpumask.html">
            
                <a href="../Concepts/cpumask.html">
            
                    
                    Cpumasks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.3" data-path="../Concepts/initcall.html">
            
                <a href="../Concepts/initcall.html">
            
                    
                    The initcall mechanism
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="../DataStructures/">
            
                <a href="../DataStructures/">
            
                    
                    Data Structures in the Linux Kernel
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.12.1" data-path="../DataStructures/dlist.html">
            
                <a href="../DataStructures/dlist.html">
            
                    
                    Doubly linked list
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.2" data-path="../DataStructures/radix-tree.html">
            
                <a href="../DataStructures/radix-tree.html">
            
                    
                    Radix tree
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.3" data-path="../DataStructures/bitmap.html">
            
                <a href="../DataStructures/bitmap.html">
            
                    
                    Bit arrays
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="../Theory/">
            
                <a href="../Theory/">
            
                    
                    Theory
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.13.1" data-path="../Theory/Paging.html">
            
                <a href="../Theory/Paging.html">
            
                    
                    Paging
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.2" data-path="../Theory/ELF.html">
            
                <a href="../Theory/ELF.html">
            
                    
                    Elf64
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.3" data-path="../Theory/asm.html">
            
                <a href="../Theory/asm.html">
            
                    
                    Inline assembly
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.4" >
            
                <span>
            
                    
                    CPUID
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.5" >
            
                <span>
            
                    
                    MSR
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.14" >
            
                <span>
            
                    
                    Initial ram disk
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.14.1" >
            
                <span>
            
                    
                    initrd
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="../Misc/">
            
                <a href="../Misc/">
            
                    
                    Misc
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.15.1" data-path="../Misc/how_kernel_compiled.html">
            
                <a href="../Misc/how_kernel_compiled.html">
            
                    
                    How the kernel is compiled
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.2" data-path="../Misc/linkers.html">
            
                <a href="../Misc/linkers.html">
            
                    
                    Linkers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.3" data-path="../Misc/contribute.html">
            
                <a href="../Misc/contribute.html">
            
                    
                    Linux kernel development
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.4" data-path="../Misc/program_startup.html">
            
                <a href="../Misc/program_startup.html">
            
                    
                    Program startup process in userspace
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.5" >
            
                <span>
            
                    
                    Write and Submit your first Linux kernel Patch
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.6" >
            
                <span>
            
                    
                    Data types in the kernel
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="../KernelStructures/">
            
                <a href="../KernelStructures/">
            
                    
                    KernelStructures
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.16.1" data-path="../KernelStructures/idt.html">
            
                <a href="../KernelStructures/idt.html">
            
                    
                    IDT
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.17" data-path="../LINKS.html">
            
                <a href="../LINKS.html">
            
                    
                    Useful links
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.18" data-path="../contributors.html">
            
                <a href="../contributors.html">
            
                    
                    Contributors
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Transition to 64-bit mode</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="kernel-booting-process-part-4">Kernel booting process. Part 4.</h1>
<h2 id="transition-to-64-bit-mode">Transition to 64-bit mode</h2>
<p>This is the fourth part of the <code>Kernel booting process</code> where we will see first steps in <a href="http://en.wikipedia.org/wiki/Protected_mode" target="_blank">protected mode</a>, like checking that cpu supports <a href="http://en.wikipedia.org/wiki/Long_mode" target="_blank">long mode</a> and <a href="http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions" target="_blank">SSE</a>, <a href="http://en.wikipedia.org/wiki/Paging" target="_blank">paging</a>, initializes the page tables and at the end we will discuss the transition to <a href="https://en.wikipedia.org/wiki/Long_mode" target="_blank">long mode</a>.</p>
<p><strong>NOTE: there will be much assembly code in this part, so if you are not familiar with that, you might want to consult a book about it</strong></p>
<p>In the previous <a href="https://github.com/0xAX/linux-insides/blob/master/Booting/linux-bootstrap-3.md" target="_blank">part</a> we stopped at the jump to the 32-bit entry point in <a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/pmjump.S" target="_blank">arch/x86/boot/pmjump.S</a>:</p>
<pre><code class="lang-assembly">jmpl    *%eax
</code></pre>
<p>You will recall that <code>eax</code> register contains the address of the 32-bit entry point. We can read about this in the <a href="https://www.kernel.org/doc/Documentation/x86/boot.txt" target="_blank">linux kernel x86 boot protocol</a>:</p>
<pre><code>When using bzImage, the protected-mode kernel was relocated to 0x100000
</code></pre><p>Let&apos;s make sure that it is true by looking at the register values at the 32-bit entry point:</p>
<pre><code>eax            0x100000    1048576
ecx            0x0        0
edx            0x0        0
ebx            0x0        0
esp            0x1ff5c    0x1ff5c
ebp            0x0        0x0
esi            0x14470    83056
edi            0x0        0
eip            0x100000    0x100000
eflags         0x46        [ PF ZF ]
cs             0x10    16
ss             0x18    24
ds             0x18    24
es             0x18    24
fs             0x18    24
gs             0x18    24
</code></pre><p>We can see here that <code>cs</code> register contains - <code>0x10</code> (as you will remember from the previous part, this is the second index in the Global Descriptor Table), <code>eip</code> register is <code>0x100000</code> and the base address of all segments including the code segment are zero. So we can get the physical address, it will be <code>0:0x100000</code> or just <code>0x100000</code>, as specified by the boot protocol. Now let&apos;s start with the 32-bit entry point.</p>
<h2 id="32-bit-entry-point">32-bit entry point</h2>
<p>We can find the definition of the 32-bit entry point in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/head_64.S" target="_blank">arch/x86/boot/compressed/head_64.S</a> assembly source code file:</p>
<pre><code class="lang-assembly">    __HEAD
    .code32
ENTRY(startup_32)
....
....
....
ENDPROC(startup_32)
</code></pre>
<p>First of all, why <code>compressed</code> directory? Actually <code>bzimage</code> is a gzipped <code>vmlinux + header + kernel setup code</code>. We saw the kernel setup code in all of the previous parts. So, the main goal of the <code>head_64.S</code> is to prepare for entering long mode, enter into it and then decompress the kernel. We will see all of the steps up to kernel decompression in this part.</p>
<p>There were two files in the <code>arch/x86/boot/compressed</code> directory:</p>
<ul>
<li><a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/head_32.S" target="_blank">head_32.S</a></li>
<li><a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/head_64.S" target="_blank">head_64.S</a></li>
</ul>
<p>but we will see only <code>head_64.S</code> because, as you may remember, this book is only <code>x86_64</code> related; <code>head_32.S</code> is not used in our case. Let&apos;s look at <a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/Makefile" target="_blank">arch/x86/boot/compressed/Makefile</a>. There we can see the following target:</p>
<pre><code class="lang-Makefile">vmlinux-objs-y := $(obj)/vmlinux.lds $(obj)/head_$(BITS).o $(obj)/misc.o \
    $(obj)/string.o $(obj)/cmdline.o \
    $(obj)/piggy.o $(obj)/cpuflags.o
</code></pre>
<p>Note <code>$(obj)/head_$(BITS).o</code>. This means that we will select which file to link based on what <code>$(BITS)</code> is set to, either head_32.o or head_64.o.   <code>$(BITS)</code> is defined elsewhere in <a href="https://github.com/torvalds/linux/blob/master/arch/x86/Makefile" target="_blank">arch/x86/Makefile</a> based on the .config file:</p>
<pre><code class="lang-Makefile">ifeq ($(CONFIG_X86_32),y)
        BITS := 32
        ...
        ...
else
        BITS := 64
        ...
        ...
endif
</code></pre>
<p>Now we know where to start, so let&apos;s do it.</p>
<h2 id="reload-the-segments-if-needed">Reload the segments if needed</h2>
<p>As indicated above, we start in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/head_64.S" target="_blank">arch/x86/boot/compressed/head_64.S</a> assembly source code file. First we see the definition of the special section attribute before the <code>startup_32</code> definition:</p>
<pre><code class="lang-assembly">    __HEAD
    .code32
ENTRY(startup_32)
</code></pre>
<p>The <code>__HEAD</code> is macro which is defined in <a href="https://github.com/torvalds/linux/blob/master/include/linux/init.h" target="_blank">include/linux/init.h</a> header file and expands to the definition of the following section:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __HEAD        .section    <span class="hljs-string">&quot;.head.text&quot;</span>,<span class="hljs-string">&quot;ax&quot;</span></span>
</code></pre>
<p>with <code>.head.text</code> name and <code>ax</code> flags. In our case, these flags show us that this section is <a href="https://en.wikipedia.org/wiki/Executable" target="_blank">executable</a> or in other words contains code. We can find definition of this section in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/vmlinux.lds.S" target="_blank">arch/x86/boot/compressed/vmlinux.lds.S</a> linker script:</p>
<pre><code>SECTIONS
{
    . = 0;
    .head.text : {
        _head = . ;
        HEAD_TEXT
        _ehead = . ;
    }
</code></pre><p>If you are not familiar with the syntax of <code>GNU LD</code> linker scripting language, you can find more information in the <a href="https://sourceware.org/binutils/docs/ld/Scripts.html#Scripts" target="_blank">documentation</a>. In short, the <code>.</code> symbol is a special variable of linker - location counter. The value assigned to it is an offset relative to the offset of the segment. In our case, we assign zero to location counter. This means that our code is linked to run from the <code>0</code> offset in memory. Moreover, we can find this information in comments:</p>
<pre><code>Be careful parts of head_64.S assume startup_32 is at address 0.
</code></pre><p>Ok, now we know where we are, and now is the best time to look inside the <code>startup_32</code> function.</p>
<p>In the beginning of the <code>startup_32</code> function, we can see the <code>cld</code> instruction which clears the <code>DF</code> bit in the <a href="https://en.wikipedia.org/wiki/FLAGS_register" target="_blank">flags</a> register. When direction flag is clear, all string operations like <a href="http://x86.renejeschke.de/html/file_module_x86_id_306.html" target="_blank">stos</a>, <a href="http://x86.renejeschke.de/html/file_module_x86_id_287.html" target="_blank">scas</a> and others will increment the index registers <code>esi</code> or <code>edi</code>. We need to clear direction flag because later we will use strings operations for clearing space for page tables, etc.</p>
<p>After we have cleared the <code>DF</code> bit, next step is the check of the <code>KEEP_SEGMENTS</code> flag from <code>loadflags</code> kernel setup header field. If you remember we already saw <code>loadflags</code> in the very first <a href="https://0xax.gitbooks.io/linux-insides/content/Booting/linux-bootstrap-1.html" target="_blank">part</a> of this book. There we checked <code>CAN_USE_HEAP</code> flag to get ability to use heap. Now we need to check the <code>KEEP_SEGMENTS</code> flag. This flag is described in the linux <a href="https://www.kernel.org/doc/Documentation/x86/boot.txt" target="_blank">boot protocol</a> documentation:</p>
<pre><code>Bit 6 (write): KEEP_SEGMENTS
  Protocol: 2.07+
  - If 0, reload the segment registers in the 32bit entry point.
  - If 1, do not reload the segment registers in the 32bit entry point.
    Assume that %cs %ds %ss %es are all set to flat segments with
        a base of 0 (or the equivalent for their environment).
</code></pre><p>So, if the <code>KEEP_SEGMENTS</code> bit is not set in the <code>loadflags</code>, we need to reset <code>ds</code>, <code>ss</code> and <code>es</code> segment registers to a flat segment with base <code>0</code>. That we do:</p>
<pre><code class="lang-C">    testb $(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>), BP_loadflags(%esi)
    jnz <span class="hljs-number">1f</span>

    cli
    movl    $(__BOOT_DS), %eax
    movl    %eax, %ds
    movl    %eax, %es
    movl    %eax, %ss
</code></pre>
<p>Remember that the <code>__BOOT_DS</code> is <code>0x18</code> (index of data segment in the <a href="https://en.wikipedia.org/wiki/Global_Descriptor_Table" target="_blank">Global Descriptor Table</a>). If <code>KEEP_SEGMENTS</code> is set, we jump to the nearest <code>1f</code> label or update segment registers with <code>__BOOT_DS</code> if it is not set. It is pretty easy, but here is one interesting moment. If you&apos;ve read the previous <a href="https://github.com/0xAX/linux-insides/blob/master/Booting/linux-bootstrap-3.md" target="_blank">part</a>, you may remember that we already updated these segment registers right after we switched to <a href="https://en.wikipedia.org/wiki/Protected_mode" target="_blank">protected mode</a> in <a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/pmjump.S" target="_blank">arch/x86/boot/pmjump.S</a>. So why do we need to care about values of segment registers again? The answer is easy. The Linux kernel also has a 32-bit boot protocol and if a bootloader uses it to load the Linux kernel all code before the <code>startup_32</code> will be missed. In this case, the <code>startup_32</code> will be the first entry point of the Linux kernel right after the bootloader and there are no guarantees that segment registers will be in known state.</p>
<p>After we have checked the <code>KEEP_SEGMENTS</code> flag and put the correct value to the segment registers, the next step is to calculate the difference between where we loaded and compiled to run. Remember that <code>setup.ld.S</code> contains following definition: <code>. = 0</code> at the start of the <code>.head.text</code> section. This means that the code in this section is compiled to run from <code>0</code> address. We can see this in <code>objdump</code> output:</p>
<pre><code>arch/x86/boot/compressed/vmlinux:     file format elf64-x86-64


Disassembly of section .head.text:

0000000000000000 &lt;startup_32&gt;:
   0:   fc                      cld
   1:   f6 86 11 02 00 00 40    testb  $0x40,0x211(%rsi)
</code></pre><p>The <code>objdump</code> util tells us that the address of the <code>startup_32</code> is <code>0</code> but actually it&apos;s not so. Our current goal is to know where actually we are. It is pretty simple to do in <a href="https://en.wikipedia.org/wiki/Long_mode" target="_blank">long mode</a> because it support <code>rip</code> relative addressing but currently we are in <a href="https://en.wikipedia.org/wiki/Protected_mode" target="_blank">protected mode</a>. We will use common pattern to know the address of the <code>startup_32</code>. We need to define a label and make a call to this label and pop the top of the stack to a register:</p>
<pre><code class="lang-assembly">call label
label: pop %reg
</code></pre>
<p>After this, a register will contain the address of a label. Let&apos;s look at the similar code which searches address of the <code>startup_32</code> in the Linux kernel:</p>
<pre><code class="lang-assembly">    leal    (BP_scratch+4)(%esi), %esp
    call    1f
1:  popl    %ebp
    subl    $1b, %ebp
</code></pre>
<p>As you remember from the previous part, the <code>esi</code> register contains the address of the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/uapi/asm/bootparam.h#L113" target="_blank">boot_params</a> structure which was filled before we moved to the protected mode. The <code>boot_params</code> structure contains a special field <code>scratch</code> with offset <code>0x1e4</code>. These four bytes field will be temporary stack for <code>call</code> instruction. We are getting the address of the <code>scratch</code> field + 4 bytes and putting it in the <code>esp</code> register. We add <code>4</code> bytes to the base of the <code>BP_scratch</code> field because, as just described, it will be a temporary stack and the stack grows from top to down in <code>x86_64</code> architecture. So our stack pointer will point to the top of the stack. Next, we can see the pattern that I&apos;ve described above. We make a call to the <code>1f</code> label and put the address of this label to the <code>ebp</code> register because we have return address on the top of stack after the <code>call</code> instruction will be executed. So, for now we have an address of the <code>1f</code> label and now it is easy to get address of the <code>startup_32</code>. We just need to subtract address of label from the address which we got from the stack:</p>
<pre><code>startup_32 (0x0)     +-----------------------+
                     |                       |
                     |                       |
                     |                       |
                     |                       |
                     |                       |
                     |                       |
                     |                       |
                     |                       |
1f (0x0 + 1f offset) +-----------------------+ %ebp - real physical address
                     |                       |
                     |                       |
                     +-----------------------+
</code></pre><p><code>startup_32</code> is linked to run at address <code>0x0</code> and this means that <code>1f</code> has the address <code>0x0 + offset to 1f</code>, approximately <code>0x21</code> bytes. The <code>ebp</code> register contains the real physical address of the <code>1f</code> label. So, if we subtract <code>1f</code> from the <code>ebp</code> we will get the real physical address of the <code>startup_32</code>. The Linux kernel <a href="https://www.kernel.org/doc/Documentation/x86/boot.txt" target="_blank">boot protocol</a> describes that the base of the protected mode kernel is <code>0x100000</code>. We can verify this with <a href="https://en.wikipedia.org/wiki/GNU_Debugger" target="_blank">gdb</a>. Let&apos;s start the debugger and put breakpoint to the <code>1f</code> address, which is <code>0x100021</code>. If this is correct we will see <code>0x100021</code> in the <code>ebp</code> register:</p>
<pre><code>$ gdb
(gdb)$ target remote :1234
Remote debugging using :1234
0x0000fff0 in ?? ()
(gdb)$ br *0x100022
Breakpoint 1 at 0x100022
(gdb)$ c
Continuing.

Breakpoint 1, 0x00100022 in ?? ()
(gdb)$ i r
eax            0x18    0x18
ecx            0x0    0x0
edx            0x0    0x0
ebx            0x0    0x0
esp            0x144a8    0x144a8
ebp            0x100021    0x100021
esi            0x142c0    0x142c0
edi            0x0    0x0
eip            0x100022    0x100022
eflags         0x46    [ PF ZF ]
cs             0x10    0x10
ss             0x18    0x18
ds             0x18    0x18
es             0x18    0x18
fs             0x18    0x18
gs             0x18    0x18
</code></pre><p>If we execute the next instruction, <code>subl $1b, %ebp</code>, we will see:</p>
<pre><code>nexti
...
ebp            0x100000    0x100000
...
</code></pre><p>Ok, that&apos;s true. The address of the <code>startup_32</code> is <code>0x100000</code>. After we know the address of the <code>startup_32</code> label, we can prepare for the transition to <a href="https://en.wikipedia.org/wiki/Long_mode" target="_blank">long mode</a>. Our next goal is to setup the stack and verify that the CPU supports long mode and <a href="http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions" target="_blank">SSE</a>.</p>
<h2 id="stack-setup-and-cpu-verification">Stack setup and CPU verification</h2>
<p>We could not setup the stack while we did not know the address of the <code>startup_32</code> label. We can imagine the stack as an array and the stack pointer register <code>esp</code> must point to the end of this array. Of course, we can define an array in our code, but we need to know its actual address to configure the stack pointer in a correct way. Let&apos;s look at the code:</p>
<pre><code class="lang-assembly">    movl    $boot_stack_end, %eax
    addl    %ebp, %eax
    movl    %eax, %esp
</code></pre>
<p>The <code>boot_stack_end</code> label, defined in the same <a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/head_64.S" target="_blank">arch/x86/boot/compressed/head_64.S</a> assembly source code file and located in the <a href="https://en.wikipedia.org/wiki/.bss" target="_blank">.bss</a> section:</p>
<pre><code class="lang-assembly">    .bss
    .balign 4
boot_heap:
    .fill BOOT_HEAP_SIZE, 1, 0
boot_stack:
    .fill BOOT_STACK_SIZE, 1, 0
boot_stack_end:
</code></pre>
<p>First of all, we put the address of <code>boot_stack_end</code> into the <code>eax</code> register, so the <code>eax</code> register contains the address of <code>boot_stack_end</code> where it was linked, which is <code>0x0 + boot_stack_end</code>. To get the real address of <code>boot_stack_end</code>, we need to add the real address of the <code>startup_32</code>. As you remember, we have found this address above and put it to the <code>ebp</code> register. In the end, the register <code>eax</code> will contain real address of the <code>boot_stack_end</code> and we just need to put to the stack pointer.</p>
<p>After we have set up the stack, next step is CPU verification. As we are going to execute transition to the <code>long mode</code>, we need to check that the CPU supports <code>long mode</code> and <code>SSE</code>. We will do it by the call of the <code>verify_cpu</code> function:</p>
<pre><code class="lang-assembly">    call    verify_cpu
    testl    %eax, %eax
    jnz    no_longmode
</code></pre>
<p>This function defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/verify_cpu.S" target="_blank">arch/x86/kernel/verify_cpu.S</a> assembly file and just contains a couple of calls to the <a href="https://en.wikipedia.org/wiki/CPUID" target="_blank">cpuid</a> instruction. This instruction is used for getting information about the processor. In our case, it checks <code>long mode</code> and <code>SSE</code> support and returns <code>0</code> on success or <code>1</code> on fail in the <code>eax</code> register.</p>
<p>If the value of the <code>eax</code> is not zero, we jump to the <code>no_longmode</code> label which just stops the CPU by the call of the <code>hlt</code> instruction while no hardware interrupt will not happen:</p>
<pre><code class="lang-assembly">no_longmode:
1:
    hlt
    jmp     1b
</code></pre>
<p>If the value of the <code>eax</code> register is zero, everything is ok and we are able to continue.</p>
<h2 id="calculate-relocation-address">Calculate relocation address</h2>
<p>The next step is calculating relocation address for decompression if needed. First we need to know what it means for a kernel to be <code>relocatable</code>. We already know that the base address of the 32-bit entry point of the Linux kernel is <code>0x100000</code>, but that is a 32-bit entry point. The default base address of the Linux kernel is determined by the value of the <code>CONFIG_PHYSICAL_START</code> kernel configuration option. Its default value is <code>0x1000000</code> or <code>16 MB</code>. The main problem here is that if the Linux kernel crashes, a kernel developer must have a <code>rescue kernel</code> for <a href="https://www.kernel.org/doc/Documentation/kdump/kdump.txt" target="_blank">kdump</a> which is configured to load from a different address. The Linux kernel provides special configuration option to solve this problem: <code>CONFIG_RELOCATABLE</code>. As we can read in the documentation of the Linux kernel:</p>
<pre><code>This builds a kernel image that retains relocation information
so it can be loaded someplace besides the default 1MB.

Note: If CONFIG_RELOCATABLE=y, then the kernel runs from the address
it has been loaded at and the compile time physical address
(CONFIG_PHYSICAL_START) is used as the minimum location.
</code></pre><p>In simple terms this means that the Linux kernel with the same configuration can be booted from different addresses. Technically, this is done by compiling the decompressor as <a href="https://en.wikipedia.org/wiki/Position-independent_code" target="_blank">position independent code</a>. If we look at <a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/Makefile" target="_blank">arch/x86/boot/compressed/Makefile</a>, we will see that the decompressor is indeed compiled with the <code>-fPIC</code> flag:</p>
<pre><code class="lang-Makefile">KBUILD_CFLAGS += -fno-strict-aliasing -fPIC
</code></pre>
<p>When we are using position-independent code an address is obtained by adding the address field of the command and the value of the program counter. We can load code which uses such addressing from any address. That&apos;s why we had to get the real physical address of <code>startup_32</code>. Now let&apos;s get back to the Linux kernel code. Our current goal is to calculate an address where we can relocate the kernel for decompression. Calculation of this address depends on <code>CONFIG_RELOCATABLE</code> kernel configuration option. Let&apos;s look at the code:</p>
<pre><code class="lang-assembly">#ifdef CONFIG_RELOCATABLE
    movl    %ebp, %ebx
    movl    BP_kernel_alignment(%esi), %eax
    decl    %eax
    addl    %eax, %ebx
    notl    %eax
    andl    %eax, %ebx
    cmpl    $LOAD_PHYSICAL_ADDR, %ebx
    jge    1f
#endif
    movl    $LOAD_PHYSICAL_ADDR, %ebx
1:
    addl    $z_extract_offset, %ebx
</code></pre>
<p>Remember that the value of the <code>ebp</code> register is the physical address of the <code>startup_32</code> label. If the <code>CONFIG_RELOCATABLE</code> kernel configuration option is enabled during kernel configuration, we put this address in the <code>ebx</code> register, align it to a multiple of <code>2MB</code> and compare it with the <code>LOAD_PHYSICAL_ADDR</code> value. The <code>LOAD_PHYSICAL_ADDR</code> macro is defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/boot.h" target="_blank">arch/x86/include/asm/boot.h</a> header file and it looks like this:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOAD_PHYSICAL_ADDR ((CONFIG_PHYSICAL_START \
                + (CONFIG_PHYSICAL_ALIGN - 1)) \
                &amp; ~(CONFIG_PHYSICAL_ALIGN - 1))</span>
</code></pre>
<p>As we can see it just expands to the aligned <code>CONFIG_PHYSICAL_ALIGN</code> value which represents the physical address of where to load the kernel. After comparison of the <code>LOAD_PHYSICAL_ADDR</code> and value of the <code>ebx</code> register, we add the offset from the <code>startup_32</code> where to decompress the compressed kernel image. If the <code>CONFIG_RELOCATABLE</code> option is not enabled during kernel configuration, we just put the default address where to load kernel and add <code>z_extract_offset</code> to it.</p>
<p>After all of these calculations, we will have <code>ebp</code> which contains the address where we loaded it and <code>ebx</code> set to the address of where kernel will be moved after decompression.</p>
<h2 id="preparation-before-entering-long-mode">Preparation before entering long mode</h2>
<p>When we have the base address where we will relocate the compressed kernel image, we need to do one last step before we can transition to 64-bit mode. First, we need to update the <a href="https://en.wikipedia.org/wiki/Global_Descriptor_Table" target="_blank">Global Descriptor Table</a>:</p>
<pre><code class="lang-assembly">    leal    gdt(%ebp), %eax
    movl    %eax, gdt+2(%ebp)
    lgdt    gdt(%ebp)
</code></pre>
<p>Here we put the base address from <code>ebp</code> register with <code>gdt</code> offset into the <code>eax</code> register. Next we put this address into <code>ebp</code> register with offset <code>gdt+2</code> and load the <code>Global Descriptor Table</code> with the <code>lgdt</code> instruction. To understand the magic with <code>gdt</code> offsets we need to look at the definition of the <code>Global Descriptor Table</code>. We can find its definition in the same source code <a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/head_64.S" target="_blank">file</a>:</p>
<pre><code class="lang-assembly">    .data
gdt:
    .word    gdt_end - gdt
    .long    gdt
    .word    0
    .quad    0x0000000000000000    /* NULL descriptor */
    .quad    0x00af9a000000ffff    /* __KERNEL_CS */
    .quad    0x00cf92000000ffff    /* __KERNEL_DS */
    .quad    0x0080890000000000    /* TS descriptor */
    .quad   0x0000000000000000    /* TS continued */
gdt_end:
</code></pre>
<p>We can see that it is located in the <code>.data</code> section and contains five descriptors: <code>null</code> descriptor, kernel code segment, kernel data segment and two task descriptors. We already loaded the <code>Global Descriptor Table</code> in the previous <a href="https://github.com/0xAX/linux-insides/blob/master/Booting/linux-bootstrap-3.md" target="_blank">part</a>, and now we&apos;re doing almost the same here, but descriptors with <code>CS.L = 1</code> and <code>CS.D = 0</code> for execution in <code>64</code> bit mode. As we can see, the definition of the <code>gdt</code> starts from two bytes: <code>gdt_end - gdt</code> which represents the last byte in the <code>gdt</code> table or table limit. The next four bytes contains base address of the <code>gdt</code>. Remember that the <code>Global Descriptor Table</code> is stored in the <code>48-bits GDTR</code> which consists of two parts:</p>
<ul>
<li>size(16-bit) of global descriptor table;</li>
<li>address(32-bit) of the global descriptor table.</li>
</ul>
<p>So, we put address of the <code>gdt</code> to the <code>eax</code> register and then we put it to the <code>.long    gdt</code> or <code>gdt+2</code> in our assembly code. From now we have formed structure for the <code>GDTR</code> register and can load the <code>Global Descriptor Table</code> with the <code>lgtd</code> instruction.</p>
<p>After we have loaded the <code>Global Descriptor Table</code>, we must enable <a href="http://en.wikipedia.org/wiki/Physical_Address_Extension" target="_blank">PAE</a> mode by putting the value of the <code>cr4</code> register into <code>eax</code>, setting 5 bit in it and loading it again into <code>cr4</code>:</p>
<pre><code class="lang-assembly">    movl    %cr4, %eax
    orl    $X86_CR4_PAE, %eax
    movl    %eax, %cr4
</code></pre>
<p>Now we are almost finished with all preparations before we can move into 64-bit mode. The last step is to build page tables, but before that, here is some information about long mode.</p>
<h2 id="long-mode">Long mode</h2>
<p><a href="https://en.wikipedia.org/wiki/Long_mode" target="_blank">Long mode</a> is the native mode for <a href="https://en.wikipedia.org/wiki/X86-64" target="_blank">x86_64</a> processors. First, let&apos;s look at some differences between <code>x86_64</code> and the <code>x86</code>.</p>
<p>The <code>64-bit</code> mode provides features such as:</p>
<ul>
<li>New 8 general purpose registers from <code>r8</code> to <code>r15</code> + all general purpose registers are 64-bit now;</li>
<li>64-bit instruction pointer - <code>RIP</code>;</li>
<li>New operating mode - Long mode;</li>
<li>64-Bit Addresses and Operands;</li>
<li>RIP Relative Addressing (we will see an example of it in the next parts).</li>
</ul>
<p>Long mode is an extension of legacy protected mode. It consists of two sub-modes:</p>
<ul>
<li>64-bit mode;</li>
<li>compatibility mode.</li>
</ul>
<p>To switch into <code>64-bit</code> mode we need to do following things:</p>
<ul>
<li>Enable <a href="https://en.wikipedia.org/wiki/Physical_Address_Extension" target="_blank">PAE</a>;</li>
<li>Build page tables and load the address of the top level page table into the <code>cr3</code> register;</li>
<li>Enable <code>EFER.LME</code>;</li>
<li>Enable paging.</li>
</ul>
<p>We already enabled <code>PAE</code> by setting the <code>PAE</code> bit in the <code>cr4</code> control register. Our next goal is to build the structure for <a href="https://en.wikipedia.org/wiki/Paging" target="_blank">paging</a>. We will see this in next paragraph.</p>
<h2 id="early-page-table-initialization">Early page table initialization</h2>
<p>So, we already know that before we can move into <code>64-bit</code> mode, we need to build page tables, so, let&apos;s look at the building of early <code>4G</code> boot page tables.</p>
<p><strong>NOTE: I will not describe the theory of virtual memory here. If you need to know more about it, see links at the end of this part.</strong></p>
<p>The Linux kernel uses <code>4-level</code> paging, and we generally build 6 page tables:</p>
<ul>
<li>One <code>PML4</code> or <code>Page Map Level 4</code> table with one entry;</li>
<li>One <code>PDP</code> or <code>Page Directory Pointer</code> table with four entries;</li>
<li>Four Page Directory tables with a total of <code>2048</code> entries.</li>
</ul>
<p>Let&apos;s look at the implementation of this. First of all, we clear the buffer for the page tables in memory. Every table is <code>4096</code> bytes, so we need clear <code>24</code> kilobyte buffer:</p>
<pre><code class="lang-assembly">    leal    pgtable(%ebx), %edi
    xorl    %eax, %eax
    movl    $((4096*6)/4), %ecx
    rep    stosl
</code></pre>
<p>We put the address of <code>pgtable</code> plus <code>ebx</code> (remember that <code>ebx</code> contains the address to relocate the kernel for decompression) in the <code>edi</code> register, clear the <code>eax</code> register and set the <code>ecx</code> register to <code>6144</code>. The <code>rep stosl</code> instruction will write the value of the <code>eax</code> to <code>edi</code>, increase value of the <code>edi</code> register by <code>4</code> and decrease the value of the <code>ecx</code> register by <code>1</code>. This operation will be repeated while the value of the <code>ecx</code> register is greater than zero. That&apos;s why we put <code>6144</code> in <code>ecx</code>.</p>
<p><code>pgtable</code> is defined at the end of <a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/head_64.S" target="_blank">arch/x86/boot/compressed/head_64.S</a> assembly file and is:</p>
<pre><code class="lang-assembly">    .section &quot;.pgtable&quot;,&quot;a&quot;,@nobits
    .balign 4096
pgtable:
    .fill 6*4096, 1, 0
</code></pre>
<p>As we can see, it is located in the <code>.pgtable</code> section and its size is <code>24</code> kilobytes.</p>
<p>After we have got buffer for the <code>pgtable</code> structure, we can start to build the top level page table - <code>PML4</code> - with:</p>
<pre><code class="lang-assembly">    leal    pgtable + 0(%ebx), %edi
    leal    0x1007 (%edi), %eax
    movl    %eax, 0(%edi)
</code></pre>
<p>Here again, we put the address of the <code>pgtable</code> relative to <code>ebx</code> or in other words relative to address of the <code>startup_32</code> to the <code>edi</code> register. Next, we put this address with offset <code>0x1007</code> in the <code>eax</code> register. The <code>0x1007</code> is <code>4096</code> bytes which is the size of the <code>PML4</code> plus <code>7</code>. The <code>7</code> here represents flags of the <code>PML4</code> entry. In our case, these flags are <code>PRESENT+RW+USER</code>. In the end, we just write first the address of the first <code>PDP</code> entry to the <code>PML4</code>.</p>
<p>In the next step we will build four <code>Page Directory</code> entries in the <code>Page Directory Pointer</code> table with the same <code>PRESENT+RW+USE</code> flags:</p>
<pre><code class="lang-assembly">    leal    pgtable + 0x1000(%ebx), %edi
    leal    0x1007(%edi), %eax
    movl    $4, %ecx
1:  movl    %eax, 0x00(%edi)
    addl    $0x00001000, %eax
    addl    $8, %edi
    decl    %ecx
    jnz    1b
</code></pre>
<p>We put the base address of the page directory pointer which is <code>4096</code> or <code>0x1000</code> offset from the <code>pgtable</code> table in <code>edi</code> and the address of the first page directory pointer entry in <code>eax</code> register. Put <code>4</code> in the <code>ecx</code> register, it will be a counter in the following loop and write the address of the first page directory pointer table entry to the <code>edi</code> register. After this <code>edi</code> will contain the address of the first page directory pointer entry with flags <code>0x7</code>. Next we just calculate the address of following page directory pointer entries where each entry is <code>8</code> bytes, and write their addresses to <code>eax</code>. The last step of building paging structure is the building of the <code>2048</code> page table entries with <code>2-MByte</code> pages:</p>
<pre><code class="lang-assembly">    leal    pgtable + 0x2000(%ebx), %edi
    movl    $0x00000183, %eax
    movl    $2048, %ecx
1:  movl    %eax, 0(%edi)
    addl    $0x00200000, %eax
    addl    $8, %edi
    decl    %ecx
    jnz    1b
</code></pre>
<p>Here we do almost the same as in the previous example, all entries will be with flags - <code>$0x00000183</code> - <code>PRESENT + WRITE + MBZ</code>. In the end, we will have <code>2048</code> pages with <code>2-MByte</code> page or:</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">2048</span> * <span class="hljs-number">0x00200000</span>
<span class="hljs-number">4294967296</span>
</code></pre>
<p><code>4G</code> page table. We just finished to build our early page table structure which maps <code>4</code> gigabytes of memory and now we can put the address of the high-level page table - <code>PML4</code> - in <code>cr3</code> control register:</p>
<pre><code class="lang-assembly">    leal    pgtable(%ebx), %eax
    movl    %eax, %cr3
</code></pre>
<p>That&apos;s all. All preparation are finished and now we can see transition to the long mode.</p>
<h2 id="transition-to-the-64-bit-mode">Transition to the 64-bit mode</h2>
<p>First of all we need to set the <code>EFER.LME</code> flag in the <a href="http://en.wikipedia.org/wiki/Model-specific_register" target="_blank">MSR</a> to <code>0xC0000080</code>:</p>
<pre><code class="lang-assembly">    movl    $MSR_EFER, %ecx
    rdmsr
    btsl    $_EFER_LME, %eax
    wrmsr
</code></pre>
<p>Here we put the <code>MSR_EFER</code> flag (which is defined in <a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/uapi/asm/msr-index.h#L7" target="_blank">arch/x86/include/uapi/asm/msr-index.h</a>) in the <code>ecx</code> register and call <code>rdmsr</code> instruction which reads the <a href="http://en.wikipedia.org/wiki/Model-specific_register" target="_blank">MSR</a> register. After <code>rdmsr</code> executes, we will have the resulting data in <code>edx:eax</code> which depends on the <code>ecx</code> value. We check the <code>EFER_LME</code> bit with the <code>btsl</code> instruction and write data from <code>eax</code> to the <code>MSR</code> register with the <code>wrmsr</code> instruction.</p>
<p>In the next step, we push the address of the kernel segment code to the stack (we defined it in the GDT) and put the address of the <code>startup_64</code> routine in <code>eax</code>.</p>
<pre><code class="lang-assembly">    pushl    $__KERNEL_CS
    leal    startup_64(%ebp), %eax
</code></pre>
<p>After this we push this address to the stack and enable paging by setting <code>PG</code> and <code>PE</code> bits in the <code>cr0</code> register:</p>
<pre><code class="lang-assembly">    movl    $(X86_CR0_PG | X86_CR0_PE), %eax
    movl    %eax, %cr0
</code></pre>
<p>and execute:</p>
<pre><code class="lang-assembly">lret
</code></pre>
<p>instruction. Remember that we pushed the address of the <code>startup_64</code> function to the stack in the previous step, and after the <code>lret</code> instruction, the CPU extracts the address of it and jumps there.</p>
<p>After all of these steps we&apos;re finally in 64-bit mode:</p>
<pre><code class="lang-assembly">    .code64
    .org 0x200
ENTRY(startup_64)
....
....
....
</code></pre>
<p>That&apos;s all!</p>
<h2 id="conclusion">Conclusion</h2>
<p>This is the end of the fourth part linux kernel booting process. If you have questions or suggestions, ping me in twitter <a href="https://twitter.com/0xAX" target="_blank">0xAX</a>, drop me <a href="anotherworldofworld@gmail.com">email</a> or just create an <a href="https://github.com/0xAX/linux-insides/issues/new" target="_blank">issue</a>.</p>
<p>In the next part, we will see kernel decompression and much more.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-internals" target="_blank">linux-insides</a>.</strong></p>
<h2 id="links">Links</h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Protected_mode" target="_blank">Protected mode</a></li>
<li><a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html" target="_blank">Intel&#xAE; 64 and IA-32 Architectures Software Developer&#x2019;s Manual 3A</a></li>
<li><a href="http://www.eecs.umich.edu/courses/eecs373/readings/Linker.pdf" target="_blank">GNU linker</a></li>
<li><a href="http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions" target="_blank">SSE</a></li>
<li><a href="http://en.wikipedia.org/wiki/Paging" target="_blank">Paging</a></li>
<li><a href="http://en.wikipedia.org/wiki/Model-specific_register" target="_blank">Model specific register</a></li>
<li><a href="http://www.chemie.fu-berlin.de/chemnet/use/info/gas/gas_7.html" target="_blank">.fill instruction</a></li>
<li><a href="https://github.com/0xAX/linux-insides/blob/master/Booting/linux-bootstrap-3.md" target="_blank">Previous part</a></li>
<li><a href="http://wiki.osdev.org/Paging" target="_blank">Paging on osdev.org</a></li>
<li><a href="https://www.cs.rutgers.edu/~pxk/416/notes/09a-paging.html" target="_blank">Paging Systems</a></li>
<li><a href="http://www.cirosantilli.com/x86-paging/" target="_blank">x86 Paging Tutorial</a></li>
</ul>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="linux-bootstrap-3.html" class="navigation navigation-prev " aria-label="Previous page: Video mode initialization and transition to protected mode">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="linux-bootstrap-5.html" class="navigation navigation-next " aria-label="Next page: Kernel decompression">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Transition to 64-bit mode","level":"1.2.4","depth":2,"next":{"title":"Kernel decompression","level":"1.2.5","depth":2,"path":"Booting/linux-bootstrap-5.md","ref":"Booting/linux-bootstrap-5.md","articles":[]},"previous":{"title":"Video mode initialization and transition to protected mode","level":"1.2.3","depth":2,"path":"Booting/linux-bootstrap-3.md","ref":"Booting/linux-bootstrap-3.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"Booting/linux-bootstrap-4.md","mtime":"2019-03-28T07:54:50.382Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2019-03-28T08:16:32.758Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

