
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Fixmaps and ioremap Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="linux-mm-3.html" />
    
    
    <link rel="prev" href="linux-mm-1.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        <li class="header">Summary</li>
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../Booting/">
            
                <a href="../Booting/">
            
                    
                    Booting
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../Booting/linux-bootstrap-1.html">
            
                <a href="../Booting/linux-bootstrap-1.html">
            
                    
                    From bootloader to kernel
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../Booting/linux-bootstrap-2.html">
            
                <a href="../Booting/linux-bootstrap-2.html">
            
                    
                    First steps in the kernel setup code
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../Booting/linux-bootstrap-3.html">
            
                <a href="../Booting/linux-bootstrap-3.html">
            
                    
                    Video mode initialization and transition to protected mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="../Booting/linux-bootstrap-4.html">
            
                <a href="../Booting/linux-bootstrap-4.html">
            
                    
                    Transition to 64-bit mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="../Booting/linux-bootstrap-5.html">
            
                <a href="../Booting/linux-bootstrap-5.html">
            
                    
                    Kernel decompression
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../Initialization/">
            
                <a href="../Initialization/">
            
                    
                    Initialization
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../Initialization/linux-initialization-1.html">
            
                <a href="../Initialization/linux-initialization-1.html">
            
                    
                    First steps in the kernel
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../Initialization/linux-initialization-2.html">
            
                <a href="../Initialization/linux-initialization-2.html">
            
                    
                    Early interrupts handler
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../Initialization/linux-initialization-3.html">
            
                <a href="../Initialization/linux-initialization-3.html">
            
                    
                    Last preparations before the kernel entry point
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../Initialization/linux-initialization-4.html">
            
                <a href="../Initialization/linux-initialization-4.html">
            
                    
                    Kernel entry point
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="../Initialization/linux-initialization-5.html">
            
                <a href="../Initialization/linux-initialization-5.html">
            
                    
                    Continue architecture-specific boot-time initializations
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="../Initialization/linux-initialization-6.html">
            
                <a href="../Initialization/linux-initialization-6.html">
            
                    
                    Architecture-specific initializations, again...
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="../Initialization/linux-initialization-7.html">
            
                <a href="../Initialization/linux-initialization-7.html">
            
                    
                    End of the architecture-specific initializations, almost...
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="../Initialization/linux-initialization-8.html">
            
                <a href="../Initialization/linux-initialization-8.html">
            
                    
                    Scheduler initialization
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.9" data-path="../Initialization/linux-initialization-9.html">
            
                <a href="../Initialization/linux-initialization-9.html">
            
                    
                    RCU initialization
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.10" data-path="../Initialization/linux-initialization-10.html">
            
                <a href="../Initialization/linux-initialization-10.html">
            
                    
                    End of initialization
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../interrupts/">
            
                <a href="../interrupts/">
            
                    
                    Interrupts
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../interrupts/interrupts-1.html">
            
                <a href="../interrupts/interrupts-1.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../interrupts/interrupts-2.html">
            
                <a href="../interrupts/interrupts-2.html">
            
                    
                    Start to dive into interrupts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../interrupts/interrupts-3.html">
            
                <a href="../interrupts/interrupts-3.html">
            
                    
                    Interrupt handlers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="../interrupts/interrupts-4.html">
            
                <a href="../interrupts/interrupts-4.html">
            
                    
                    Initialization of non-early interrupt gates
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.5" data-path="../interrupts/interrupts-5.html">
            
                <a href="../interrupts/interrupts-5.html">
            
                    
                    Implementation of some exception handlers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.6" data-path="../interrupts/interrupts-6.html">
            
                <a href="../interrupts/interrupts-6.html">
            
                    
                    Handling Non-Maskable interrupts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.7" data-path="../interrupts/interrupts-7.html">
            
                <a href="../interrupts/interrupts-7.html">
            
                    
                    Dive into external hardware interrupts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.8" data-path="../interrupts/interrupts-8.html">
            
                <a href="../interrupts/interrupts-8.html">
            
                    
                    Initialization of external hardware interrupts structures
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.9" data-path="../interrupts/interrupts-9.html">
            
                <a href="../interrupts/interrupts-9.html">
            
                    
                    Softirq, Tasklets and Workqueues
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.10" data-path="../interrupts/interrupts-10.html">
            
                <a href="../interrupts/interrupts-10.html">
            
                    
                    Last part
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../SysCall/">
            
                <a href="../SysCall/">
            
                    
                    System calls
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../SysCall/syscall-1.html">
            
                <a href="../SysCall/syscall-1.html">
            
                    
                    Introduction to system calls
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="../SysCall/syscall-2.html">
            
                <a href="../SysCall/syscall-2.html">
            
                    
                    How the Linux kernel handles a system call
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="../SysCall/syscall-3.html">
            
                <a href="../SysCall/syscall-3.html">
            
                    
                    vsyscall and vDSO
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="../SysCall/syscall-4.html">
            
                <a href="../SysCall/syscall-4.html">
            
                    
                    How the Linux kernel runs a program
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.5" data-path="../SysCall/syscall-5.html">
            
                <a href="../SysCall/syscall-5.html">
            
                    
                    Implementation of the open system call
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../Timers/">
            
                <a href="../Timers/">
            
                    
                    Timers and time management
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../Timers/timers-1.html">
            
                <a href="../Timers/timers-1.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="../Timers/timers-2.html">
            
                <a href="../Timers/timers-2.html">
            
                    
                    Clocksource framework
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="../Timers/timers-3.html">
            
                <a href="../Timers/timers-3.html">
            
                    
                    The tick broadcast framework and dyntick
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="../Timers/timers-4.html">
            
                <a href="../Timers/timers-4.html">
            
                    
                    Introduction to timers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.5" data-path="../Timers/timers-5.html">
            
                <a href="../Timers/timers-5.html">
            
                    
                    Clockevents framework
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.6" data-path="../Timers/timers-6.html">
            
                <a href="../Timers/timers-6.html">
            
                    
                    x86 related clock sources
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.7" data-path="../Timers/timers-7.html">
            
                <a href="../Timers/timers-7.html">
            
                    
                    Time related system calls
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../SyncPrim/">
            
                <a href="../SyncPrim/">
            
                    
                    Synchronization primitives
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="../SyncPrim/sync-1.html">
            
                <a href="../SyncPrim/sync-1.html">
            
                    
                    Introduction to spinlocks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="../SyncPrim/sync-2.html">
            
                <a href="../SyncPrim/sync-2.html">
            
                    
                    Queued spinlocks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="../SyncPrim/sync-3.html">
            
                <a href="../SyncPrim/sync-3.html">
            
                    
                    Semaphores
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4" data-path="../SyncPrim/sync-4.html">
            
                <a href="../SyncPrim/sync-4.html">
            
                    
                    Mutex
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5" data-path="../SyncPrim/sync-5.html">
            
                <a href="../SyncPrim/sync-5.html">
            
                    
                    Reader/Writer semaphores
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.6" data-path="../SyncPrim/sync-6.html">
            
                <a href="../SyncPrim/sync-6.html">
            
                    
                    SeqLock
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.7" >
            
                <span>
            
                    
                    RCU
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.8" >
            
                <span>
            
                    
                    Lockdep
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="./">
            
                <a href="./">
            
                    
                    Memory management
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="linux-mm-1.html">
            
                <a href="linux-mm-1.html">
            
                    
                    Memblock
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.8.2" data-path="linux-mm-2.html">
            
                <a href="linux-mm-2.html">
            
                    
                    Fixmaps and ioremap
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="linux-mm-3.html">
            
                <a href="linux-mm-3.html">
            
                    
                    kmemcheck
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="../Cgroups/">
            
                <a href="../Cgroups/">
            
                    
                    Cgroups
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="../Cgroups/cgroups1.html">
            
                <a href="../Cgroups/cgroups1.html">
            
                    
                    Introduction to Control Groups
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" >
            
                <span>
            
                    
                    SMP
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="../Concepts/">
            
                <a href="../Concepts/">
            
                    
                    Concepts
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.11.1" data-path="../Concepts/per-cpu.html">
            
                <a href="../Concepts/per-cpu.html">
            
                    
                    Per-CPU variables
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.2" data-path="../Concepts/cpumask.html">
            
                <a href="../Concepts/cpumask.html">
            
                    
                    Cpumasks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.3" data-path="../Concepts/initcall.html">
            
                <a href="../Concepts/initcall.html">
            
                    
                    The initcall mechanism
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="../DataStructures/">
            
                <a href="../DataStructures/">
            
                    
                    Data Structures in the Linux Kernel
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.12.1" data-path="../DataStructures/dlist.html">
            
                <a href="../DataStructures/dlist.html">
            
                    
                    Doubly linked list
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.2" data-path="../DataStructures/radix-tree.html">
            
                <a href="../DataStructures/radix-tree.html">
            
                    
                    Radix tree
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.3" data-path="../DataStructures/bitmap.html">
            
                <a href="../DataStructures/bitmap.html">
            
                    
                    Bit arrays
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="../Theory/">
            
                <a href="../Theory/">
            
                    
                    Theory
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.13.1" data-path="../Theory/Paging.html">
            
                <a href="../Theory/Paging.html">
            
                    
                    Paging
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.2" data-path="../Theory/ELF.html">
            
                <a href="../Theory/ELF.html">
            
                    
                    Elf64
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.3" data-path="../Theory/asm.html">
            
                <a href="../Theory/asm.html">
            
                    
                    Inline assembly
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.4" >
            
                <span>
            
                    
                    CPUID
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.5" >
            
                <span>
            
                    
                    MSR
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.14" >
            
                <span>
            
                    
                    Initial ram disk
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.14.1" >
            
                <span>
            
                    
                    initrd
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="../Misc/">
            
                <a href="../Misc/">
            
                    
                    Misc
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.15.1" data-path="../Misc/how_kernel_compiled.html">
            
                <a href="../Misc/how_kernel_compiled.html">
            
                    
                    How the kernel is compiled
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.2" data-path="../Misc/linkers.html">
            
                <a href="../Misc/linkers.html">
            
                    
                    Linkers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.3" data-path="../Misc/contribute.html">
            
                <a href="../Misc/contribute.html">
            
                    
                    Linux kernel development
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.4" data-path="../Misc/program_startup.html">
            
                <a href="../Misc/program_startup.html">
            
                    
                    Program startup process in userspace
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.5" >
            
                <span>
            
                    
                    Write and Submit your first Linux kernel Patch
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.6" >
            
                <span>
            
                    
                    Data types in the kernel
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="../KernelStructures/">
            
                <a href="../KernelStructures/">
            
                    
                    KernelStructures
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.16.1" data-path="../KernelStructures/idt.html">
            
                <a href="../KernelStructures/idt.html">
            
                    
                    IDT
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.17" data-path="../LINKS.html">
            
                <a href="../LINKS.html">
            
                    
                    Useful links
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.18" data-path="../contributors.html">
            
                <a href="../contributors.html">
            
                    
                    Contributors
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Fixmaps and ioremap</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="linux-kernel-memory-management-part-2">Linux kernel memory management Part 2.</h1>
<h2 id="fix-mapped-addresses-and-ioremap">Fix-Mapped Addresses and ioremap</h2>
<p><code>Fix-Mapped</code> addresses are a set of special compile-time addresses whose corresponding physical addresses do not have to be a linear address minus <code>__START_KERNEL_map</code>. Each fix-mapped address maps one page frame and the kernel uses them as pointers that never change their address. That is the main point of these addresses. As the comment says: <code>to have a constant address at compile time, but to set the physical address only in the boot process</code>. You can remember that in the earliest <a href="http://0xax.gitbooks.io/linux-insides/content/Initialization/linux-initialization-1.html" target="_blank">part</a>, we already set the <code>level2_fixmap_pgt</code>:</p>
<pre><code class="lang-assembly">NEXT_PAGE(level2_fixmap_pgt)
    .fill    506,8,0
    .quad    level1_fixmap_pgt - __START_KERNEL_map + _PAGE_TABLE
    .fill    5,8,0

NEXT_PAGE(level1_fixmap_pgt)
    .fill    512,8,0
</code></pre>
<p>As you can see <code>level2_fixmap_pgt</code> is right after the <code>level2_kernel_pgt</code> which is kernel code+data+bss. Every fix-mapped address is represented by an integer index which is defined in the <code>fixed_addresses</code> enum from the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/fixmap.h" target="_blank">arch/x86/include/asm/fixmap.h</a>. For example it contains entries for <code>VSYSCALL_PAGE</code> - if emulation of legacy vsyscall page is enabled, <code>FIX_APIC_BASE</code> for local <a href="http://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller" target="_blank">apic</a>, etc. In virtual memory fix-mapped area is placed in the modules area:</p>
<pre><code>       +-----------+-----------------+---------------+------------------+
       |           |                 |               |                  |
       |kernel text|      kernel     |               |    vsyscalls     |
       | mapping   |       text      |    Modules    |    fix-mapped    |
       |from phys 0|       data      |               |    addresses     |
       |           |                 |               |                  |
       +-----------+-----------------+---------------+------------------+
__START_KERNEL_map   __START_KERNEL    MODULES_VADDR            0xffffffffffffffff
</code></pre><p>Base virtual address and size of the <code>fix-mapped</code> area are presented by the two following macro:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FIXADDR_SIZE    (__end_of_permanent_fixed_addresses &lt;&lt; PAGE_SHIFT)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FIXADDR_START    (FIXADDR_TOP - FIXADDR_SIZE)</span>
</code></pre>
<p>Here <code>__end_of_permanent_fixed_addresses</code> is an element of the <code>fixed_addresses</code> enum and as I wrote above: Every fix-mapped address is represented by an integer index which is defined in the <code>fixed_addresses</code>. <code>PAGE_SHIFT</code> determines the size of a page. For example size of the one page we can get with the <code>1 &lt;&lt; PAGE_SHIFT</code> expression.</p>
<p>In our case we need to get the size of the fix-mapped area, but not only of one page, that&apos;s why we are using <code>__end_of_permanent_fixed_addresses</code> for getting the size of the fix-mapped area. The <code>__end_of_permanent_fixed_addresses</code> is the last index of the <code>fixed_addresses</code> enum or in other words the <code>__end_of_permanent_fixed_addresses</code> contains amount of pages in a fixed-mapped area. So if multiply value of the <code>__end_of_permanent_fixed_addresses</code> on a page size value we will get size of fix-mapped area. In my case it&apos;s a little more than <code>536</code> kilobytes. In your case it might be a different number, because the size depends on amount of the fix-mapped addresses which are depends on your kernel&apos;s configuration.</p>
<p>The second <code>FIXADDR_START</code> macro just subtracts the fix-mapped area size from the last address of the fix-mapped area to get its base virtual address. <code>FIXADDR_TOP</code> is a rounded up address from the base address of the <a href="https://lwn.net/Articles/446528/" target="_blank">vsyscall</a> space:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FIXADDR_TOP     (round_up(VSYSCALL_ADDR + PAGE_SIZE, 1&lt;&lt;PMD_SHIFT) - PAGE_SIZE)</span>
</code></pre>
<p>The <code>fixed_addresses</code> enums are used as an index to get the virtual address by the <code>fix_to_virt</code> function. Implementation of this function is easy:</p>
<pre><code class="lang-C"><span class="hljs-keyword">static</span> __<span class="hljs-function">always_inline <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-title">fix_to_virt</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> idx)</span>
</span>{
        BUILD_BUG_ON(idx &gt;= __end_of_fixed_addresses);
        <span class="hljs-keyword">return</span> __fix_to_virt(idx);
}
</code></pre>
<p>first of all it checks that the index given for the <code>fixed_addresses</code> enum is not greater or equal than <code>__end_of_fixed_addresses</code> with the <code>BUILD_BUG_ON</code> macro and then returns the result of the <code>__fix_to_virt</code> macro:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __fix_to_virt(x)        (FIXADDR_TOP - ((x) &lt;&lt; PAGE_SHIFT))</span>
</code></pre>
<p>Here we shift left the given index of a <code>fix-mapped</code> area on the <code>PAGE_SHIFT</code> which determines size of a page as I wrote above and subtract it from the <code>FIXADDR_TOP</code> which is the highest address of the <code>fix-mapped</code> area:</p>
<pre><code>+-----------------+ 
|    PAGE 1       | FIXADDR_TOP (virt address)
|    PAGE 2       |
|    PAGE 3       |
|    PAGE 4 (idx) | x - 4
|    PAGE 5       |
+-----------------+
</code></pre><p>There is an inverse function for getting an index of a fix-mapped area corresponding to the given virtual address:</p>
<pre><code class="lang-C"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-title">virt_to_fix</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> vaddr)</span>
</span>{
        BUG_ON(vaddr &gt;= FIXADDR_TOP || vaddr &lt; FIXADDR_START);
        <span class="hljs-keyword">return</span> __virt_to_fix(vaddr);
}
</code></pre>
<p>The <code>virt_to_fix</code> takes a virtual address, checks that this address is between <code>FIXADDR_START</code> and <code>FIXADDR_TOP</code> and calls the <code>__virt_to_fix</code> macro which implemented as:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __virt_to_fix(x)        ((FIXADDR_TOP - ((x)&amp;PAGE_MASK)) &gt;&gt; PAGE_SHIFT)</span>
</code></pre>
<p>As we may see, the <code>__virt_to_fix</code> macro clears the first <code>12</code> bits in the given virtual address, subtracts it from the last address the of <code>fix-mapped</code> area (<code>FIXADDR_TOP</code>) and shifts the result right on <code>PAGE_SHIFT</code> which is <code>12</code>. Let me explain how it works.</p>
<p>As in previous example (in <code>__fix_to_virt</code> macro), we start from the top of the fix-mapped area. We also go back to bottom from the top to search an index of a fix-mapped area corresponding to the given virtual address. As you may see, forst of all we will clear the first <code>12</code> bits in the given virtual address with <code>x &amp; PAGE_MASK</code> expression. This allows us to get base address of page. We need to do this for case when the given virtual address points somewhere in a beginning/middle or end of a page, but not to the base address of it. At the next step subtract this from the <code>FIXADDR_TOP</code> and this gives us virtual address of a correspinding page in a fix-mapped area. In the end we just divide value of this address on <code>PAGE_SHIFT</code>. This gives us index of a fix-mapped area corresponding to the given virtual address. It may looks hard, but if you will go through this step by step, you will be sure that the <code>__virt_to_fix</code> macro is pretty easy.</p>
<p>That&apos;s all. For this moment we know a little about <code>fix-mapped</code> addresses, but this is enough to go next.</p>
<p><code>Fix-mapped</code> addresses are used in different <a href="http://lxr.free-electrons.com/ident?i=fix_to_virt" target="_blank">places</a> in the linux kernel. <code>IDT</code> descriptor stored there, <a href="http://en.wikipedia.org/wiki/Trusted_Execution_Technology" target="_blank">Intel Trusted Execution Technology</a> UUID stored in the <code>fix-mapped</code> area started from <code>FIX_TBOOT_BASE</code> index, <a href="http://en.wikipedia.org/wiki/Xen" target="_blank">Xen</a> bootmap and many more... We already saw a little about <code>fix-mapped</code> addresses in the fifth <a href="http://0xax.gitbooks.io/linux-insides/content/Initialization/linux-initialization-5.html" target="_blank">part</a> about of the linux kernel initialization. We use <code>fix-mapped</code> area in the early <code>ioremap</code> initialization. Let&apos;s look at it more closely and try to understand what <code>ioremap</code> is, how it is implemented in the kernel and how it is related to the <code>fix-mapped</code> addresses.</p>
<h2 id="ioremap">ioremap</h2>
<p>The Linux kernel provides many different primitives to manage memory. For this moment we will touch <code>I/O memory</code>. Every device is controlled by reading/writing from/to its registers. For example a driver can turn off/on a device by writing to its registers or get the state of a device by reading from its registers. Besides registers, many devices have buffers where a driver can write something or read from there. As we know for this moment there are two ways to access device&apos;s registers and data buffers:</p>
<ul>
<li>through the I/O ports;</li>
<li>mapping of the all registers to the memory address space;</li>
</ul>
<p>In the first case every control register of a device has a number of input and output port. A device driver can read from a port and write to it with two <code>in</code> and <code>out</code> instructions which we already saw. If you want to know about currently registered port regions, you can learn about them by accessing <code>/proc/ioports</code>:</p>
<pre><code>$ cat /proc/ioports
0000-0cf7 : PCI Bus 0000:00
  0000-001f : dma1
  0020-0021 : pic1
  0040-0043 : timer0
  0050-0053 : timer1
  0060-0060 : keyboard
  0064-0064 : keyboard
  0070-0077 : rtc0
  0080-008f : dma page reg
  00a0-00a1 : pic2
  00c0-00df : dma2
  00f0-00ff : fpu
    00f0-00f0 : PNP0C04:00
  03c0-03df : vesafb
  03f8-03ff : serial
  04d0-04d1 : pnp 00:06
  0800-087f : pnp 00:01
  0a00-0a0f : pnp 00:04
  0a20-0a2f : pnp 00:04
  0a30-0a3f : pnp 00:04
0cf8-0cff : PCI conf1
0d00-ffff : PCI Bus 0000:00
...
...
...
</code></pre><p><code>/proc/ioports</code> provides information about which driver uses which address of a <code>I/O</code> port region. All of these memory regions, for example <code>0000-0cf7</code>, were claimed with the <code>request_region</code> function from the <a href="https://github.com/torvalds/linux/blob/master/include/linux/ioport.h" target="_blank">include/linux/ioport.h</a>. Actually <code>request_region</code> is a macro which is defined as:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> request_region(start,n,name)   __request_region(&amp;ioport_resource, (start), (n), (name), 0)</span>
</code></pre>
<p>As we can see it takes three parameters:</p>
<ul>
<li><code>start</code> -  begin of region;</li>
<li><code>n</code>     -  length of region;</li>
<li><code>name</code>  -  name of requester.</li>
</ul>
<p><code>request_region</code> allocates an <code>I/O</code> port region. Very often the <code>check_region</code> function is called before the <code>request_region</code> to check that the given address range is available and the <code>release_region</code> function to release the memory region. <code>request_region</code> returns a pointer to the <code>resource</code> structure. The <code>resource</code> structure represents an abstraction for a tree-like subset of system resources. We already saw the <code>resource</code> structure in the fifth part of the kernel <a href="http://0xax.gitbooks.io/linux-insides/content/Initialization/linux-initialization-5.html" target="_blank">initialization</a> process and it looks as follows:</p>
<pre><code class="lang-C"><span class="hljs-keyword">struct</span> resource {
        <span class="hljs-keyword">resource_size_t</span> start;
        <span class="hljs-keyword">resource_size_t</span> end;
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags;
        <span class="hljs-keyword">struct</span> resource *parent, *sibling, *child;
};
</code></pre>
<p>and contains start and end addresses of the resource, the name, etc. Every <code>resource</code> structure contains pointers to the <code>parent</code>, <code>sibling</code> and <code>child</code> resources. As it has a parent and a childs, it means that every subset of resources has root <code>resource</code> structure. For example, for <code>I/O</code> ports it is the <code>ioport_resource</code> structure:</p>
<pre><code class="lang-C"><span class="hljs-keyword">struct</span> resource ioport_resource = {
         .name   = <span class="hljs-string">&quot;PCI IO&quot;</span>,
         .start  = <span class="hljs-number">0</span>,
         .end    = IO_SPACE_LIMIT,
        .flags  = IORESOURCE_IO,
};
EXPORT_SYMBOL(ioport_resource);
</code></pre>
<p>Or for <code>iomem</code>, it is the <code>iomem_resource</code> structure:</p>
<pre><code class="lang-C"><span class="hljs-keyword">struct</span> resource iomem_resource = {
        .name   = <span class="hljs-string">&quot;PCI mem&quot;</span>,
        .start  = <span class="hljs-number">0</span>,
        .end    = <span class="hljs-number">-1</span>,
        .flags  = IORESOURCE_MEM,
};
</code></pre>
<p>As I have mentioned before, <code>request_regions</code> is used to register I/O port regions and this macro is used in many <a href="http://lxr.free-electrons.com/ident?i=request_region" target="_blank">places</a> in the kernel. For example let&apos;s look at <a href="https://github.com/torvalds/linux/blob/master/drivers/char/rtc.c" target="_blank">drivers/char/rtc.c</a>. This source code file provides the <a href="http://en.wikipedia.org/wiki/Real-time_clock" target="_blank">Real Time Clock</a> interface in the linux kernel. As every kernel module, <code>rtc</code> module contains <code>module_init</code> definition:</p>
<pre><code class="lang-C">module_init(rtc_init);
</code></pre>
<p>where <code>rtc_init</code> is the <code>rtc</code> initialization function. This function is defined in the same <code>rtc.c</code> source code file. In the <code>rtc_init</code> function we can see a couple of calls to the <code>rtc_request_region</code> functions, which wrap <code>request_region</code> for example:</p>
<pre><code class="lang-C">r = rtc_request_region(RTC_IO_EXTENT);
</code></pre>
<p>where <code>rtc_request_region</code> calls:</p>
<pre><code class="lang-C">r = request_region(RTC_PORT(<span class="hljs-number">0</span>), size, <span class="hljs-string">&quot;rtc&quot;</span>);
</code></pre>
<p>Here <code>RTC_IO_EXTENT</code> is the size of the memory region and it is <code>0x8</code>, <code>&quot;rtc&quot;</code> is the name of the region and <code>RTC_PORT</code> is:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RTC_PORT(x)     (0x70 + (x))</span>
</code></pre>
<p>So with the <code>request_region(RTC_PORT(0), size, &quot;rtc&quot;)</code> we register a memory region that starts at <code>0x70</code> and and has a size of <code>0x8</code>. Let&apos;s look at <code>/proc/ioports</code>:</p>
<pre><code>~$ sudo cat /proc/ioports | grep rtc
0070-0077 : rtc0
</code></pre><p>So, we got it! Ok, that was it for the I/O ports. The second way to communicate with drivers is through the use of <code>I/O</code> memory. As I have mentioned above this works by mapping the control registers and the memory of a device to the memory address space. <code>I/O</code> memory is a set of contiguous addresses which are provided by a device to the CPU through a bus. None of the memory-mapped I/O addresses are used by the kernel directly. There is a special <code>ioremap</code> function which allows us to convert the physical address on a bus to a kernel virtual address. In other words, <code>ioremap</code> maps I/O physical memory regions to make them accessible from the kernel. The <code>ioremap</code> function takes two parameters:</p>
<ul>
<li>start of the memory region;</li>
<li>size of the memory region;</li>
</ul>
<p>The I/O memory mapping API provides functions to check, request and release memory regions as I/O memory. There are three functions for that:</p>
<ul>
<li><code>request_mem_region</code></li>
<li><code>release_mem_region</code></li>
<li><code>check_mem_region</code></li>
</ul>
<pre><code>~$ sudo cat /proc/iomem
...
...
...
be826000-be82cfff : ACPI Non-volatile Storage
be82d000-bf744fff : System RAM
bf745000-bfff4fff : reserved
bfff5000-dc041fff : System RAM
dc042000-dc0d2fff : reserved
dc0d3000-dc138fff : System RAM
dc139000-dc27dfff : ACPI Non-volatile Storage
dc27e000-deffefff : reserved
defff000-deffffff : System RAM
df000000-dfffffff : RAM buffer
e0000000-feafffff : PCI Bus 0000:00
  e0000000-efffffff : PCI Bus 0000:01
    e0000000-efffffff : 0000:01:00.0
  f7c00000-f7cfffff : PCI Bus 0000:06
    f7c00000-f7c0ffff : 0000:06:00.0
    f7c10000-f7c101ff : 0000:06:00.0
      f7c10000-f7c101ff : ahci
  f7d00000-f7dfffff : PCI Bus 0000:03
    f7d00000-f7d3ffff : 0000:03:00.0
      f7d00000-f7d3ffff : alx
...
...
...
</code></pre><p>Part of these addresses are from the call of the <code>e820_reserve_resources</code> function. We can find a call to this function in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/setup.c" target="_blank">arch/x86/kernel/setup.c</a> and the function itself is defined in <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/e820.c" target="_blank">arch/x86/kernel/e820.c</a>. <code>e820_reserve_resources</code> goes through the <a href="http://en.wikipedia.org/wiki/E820" target="_blank">e820</a> map and inserts memory regions into the root <code>iomem</code> resource structure. All <code>e820</code> memory regions which are inserted into the <code>iomem</code> resource have the following types:</p>
<pre><code class="lang-C"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-title">e820_type_to_string</span><span class="hljs-params">(<span class="hljs-keyword">int</span> e820_type)</span>
</span>{
    <span class="hljs-keyword">switch</span> (e820_type) {
    <span class="hljs-keyword">case</span> E820_RESERVED_KERN:
    <span class="hljs-keyword">case</span> E820_RAM:    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;System RAM&quot;</span>;
    <span class="hljs-keyword">case</span> E820_ACPI:    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ACPI Tables&quot;</span>;
    <span class="hljs-keyword">case</span> E820_NVS:    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ACPI Non-volatile Storage&quot;</span>;
    <span class="hljs-keyword">case</span> E820_UNUSABLE:    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Unusable memory&quot;</span>;
    <span class="hljs-keyword">default</span>:    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;reserved&quot;</span>;
    }
}
</code></pre>
<p>and we can see them in the <code>/proc/iomem</code> (read above).</p>
<p>Now let&apos;s try to understand how <code>ioremap</code> works. We already know a little about <code>ioremap</code>, we saw it in the fifth <a href="http://0xax.gitbooks.io/linux-insides/content/Initialization/linux-initialization-5.html" target="_blank">part</a> about linux kernel initialization. If you have read this part, you can remember the call of the <code>early_ioremap_init</code> function from the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/mm/ioremap.c" target="_blank">arch/x86/mm/ioremap.c</a>. Initialization of the <code>ioremap</code> is split into two parts: there is the early part which we can use before the normal <code>ioremap</code> is available and the normal <code>ioremap</code> which is available after <code>vmalloc</code> initialization and the call of <code>paging_init</code>. We do not know anything about <code>vmalloc</code> for now, so let&apos;s consider early initialization of the <code>ioremap</code>. First of all <code>early_ioremap_init</code> checks that <code>fixmap</code> is aligned on page middle directory boundary:</p>
<pre><code class="lang-C">BUILD_BUG_ON((fix_to_virt(<span class="hljs-number">0</span>) + PAGE_SIZE) &amp; ((<span class="hljs-number">1</span> &lt;&lt; PMD_SHIFT) - <span class="hljs-number">1</span>));
</code></pre>
<p>more about <code>BUILD_BUG_ON</code> you can read in the first part about <a href="http://0xax.gitbooks.io/linux-insides/content/Initialization/linux-initialization-1.html" target="_blank">Linux Kernel initialization</a>. So <code>BUILD_BUG_ON</code> macro raises a compilation error if the given expression is true. In the next step after this check, we can see call of the <code>early_ioremap_setup</code> function from the <a href="https://github.com/torvalds/linux/blob/master/mm/early_ioremap.c" target="_blank">mm/early_ioremap.c</a>. This function presents generic initialization of the <code>ioremap</code>. <code>early_ioremap_setup</code> function fills the <code>slot_virt</code> array with the virtual addresses of the early fixmaps. All early fixmaps are after <code>__end_of_permanent_fixed_addresses</code> in memory. They start at <code>FIX_BITMAP_BEGIN</code> (top) and end with <code>FIX_BITMAP_END</code> (down). Actually there are <code>512</code> temporary boot-time mappings, used by early <code>ioremap</code>:</p>
<pre><code>#define NR_FIX_BTMAPS        64
#define FIX_BTMAPS_SLOTS    8
#define TOTAL_FIX_BTMAPS    (NR_FIX_BTMAPS * FIX_BTMAPS_SLOTS)
</code></pre><p>and <code>early_ioremap_setup</code>:</p>
<pre><code class="lang-C"><span class="hljs-keyword">void</span> __<span class="hljs-function">init <span class="hljs-title">early_ioremap_setup</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
        <span class="hljs-keyword">int</span> i;

        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; FIX_BTMAPS_SLOTS; i++)
                <span class="hljs-keyword">if</span> (WARN_ON(prev_map[i]))
                        <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; FIX_BTMAPS_SLOTS; i++)
                slot_virt[i] = __fix_to_virt(FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*i);
}
</code></pre>
<p>the <code>slot_virt</code> and other arrays are defined in the same source code file:</p>
<pre><code class="lang-C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __iomem *prev_map[FIX_BTMAPS_SLOTS] __initdata;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> prev_size[FIX_BTMAPS_SLOTS] __initdata;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> slot_virt[FIX_BTMAPS_SLOTS] __initdata;
</code></pre>
<p><code>slot_virt</code> contains the virtual addresses of the <code>fix-mapped</code> areas, <code>prev_map</code> array contains addresses of the early ioremap areas. Note that I wrote above: <code>Actually there are 512 temporary boot-time mappings, used by early ioremap</code> and you can see that all arrays are defined with the <code>__initdata</code> attribute which means that this memory will be released after the kernel initialization process. After <code>early_ioremap_setup</code> has finished its work, we&apos;re getting page middle directory where early ioremap begins with the <code>early_ioremap_pmd</code> function which just gets the base address of the page global directory and calculates the page middle directory for the given address:</p>
<pre><code class="lang-C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">pmd_t</span> * __<span class="hljs-function">init <span class="hljs-title">early_ioremap_pmd</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> addr)</span>
</span>{
    <span class="hljs-keyword">pgd_t</span> *base = __va(read_cr3());
    <span class="hljs-keyword">pgd_t</span> *pgd = &amp;base[pgd_index(addr)];
    <span class="hljs-keyword">pud_t</span> *pud = pud_offset(pgd, addr);
    <span class="hljs-keyword">pmd_t</span> *pmd = pmd_offset(pud, addr);
    <span class="hljs-keyword">return</span> pmd;
}
</code></pre>
<p>After this we fill <code>bm_pte</code> (early ioremap page table entries) with zeros and call the <code>pmd_populate_kernel</code> function:</p>
<pre><code class="lang-C">pmd = early_ioremap_pmd(fix_to_virt(FIX_BTMAP_BEGIN));
<span class="hljs-built_in">memset</span>(bm_pte, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(bm_pte));
pmd_populate_kernel(&amp;init_mm, pmd, bm_pte);
</code></pre>
<p><code>pmd_populate_kernel</code> takes three parameters:</p>
<ul>
<li><code>init_mm</code> - memory descriptor of the <code>init</code> process (you can read about it in the previous <a href="http://0xax.gitbooks.io/linux-insides/content/Initialization/linux-initialization-5.html" target="_blank">part</a>);</li>
<li><code>pmd</code>     - page middle directory of the beginning of the <code>ioremap</code> fixmaps;</li>
<li><code>bm_pte</code>  - early <code>ioremap</code> page table entries array which defined as:</li>
</ul>
<pre><code class="lang-C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">pte_t</span> bm_pte[PAGE_SIZE/<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">pte_t</span>)] __page_aligned_bss;
</code></pre>
<p>The <code>pmd_populate_kernel</code> function is defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/pgalloc." target="_blank">arch/x86/include/asm/pgalloc.h</a> and populates the page middle directory (<code>pmd</code>) provided as an argument with the given page table entries (<code>bm_pte</code>):</p>
<pre><code class="lang-C"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pmd_populate_kernel</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mm_struct *mm,
                                       pmd_t *pmd, pte_t *pte)</span>
</span>{
        paravirt_alloc_pte(mm, __pa(pte) &gt;&gt; PAGE_SHIFT);
        set_pmd(pmd, __pmd(__pa(pte) | _PAGE_TABLE));
}
</code></pre>
<p>where <code>set_pmd</code> is:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_pmd(pmdp, pmd)              native_set_pmd(pmdp, pmd)</span>
</code></pre>
<p>and <code>native_set_pmd</code> is:</p>
<pre><code class="lang-C"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">native_set_pmd</span><span class="hljs-params">(pmd_t *pmdp, pmd_t pmd)</span>
</span>{
        *pmdp = pmd;
}
</code></pre>
<p>That&apos;s all. Early <code>ioremap</code> is ready to use. There are a couple of checks in the <code>early_ioremap_init</code> function, but they are not so important, anyway initialization of the <code>ioremap</code> is finished.</p>
<h2 id="use-of-early-ioremap">Use of early ioremap</h2>
<p>As soon as early <code>ioremap</code> has been setup successfully, we can use it. It provides two functions:</p>
<ul>
<li>early_ioremap</li>
<li>early_iounmap</li>
</ul>
<p>for mapping/unmapping of I/O physical address to virtual address. Both functions depend on the <code>CONFIG_MMU</code> configuration option. <a href="http://en.wikipedia.org/wiki/Memory_management_unit" target="_blank">Memory management unit</a> is a special block of memory management. The main purpose of this block is the translation of physical addresses to virtual addresses. The memory management unit knows about the high-level page table addresses (<code>pgd</code>) from the <code>cr3</code> control register. If <code>CONFIG_MMU</code> options is set to <code>n</code>, <code>early_ioremap</code> just returns the given physical address and <code>early_iounmap</code> does nothing. If <code>CONFIG_MMU</code> option is set to <code>y</code>, <code>early_ioremap</code> calls <code>__early_ioremap</code> which takes three parameters:</p>
<ul>
<li><code>phys_addr</code> - base physical address of the <code>I/O</code> memory region to map on virtual addresses;</li>
<li><code>size</code>      - size of the <code>I/O</code> memory region;</li>
<li><code>prot</code>      - page table entry bits.</li>
</ul>
<p>First of all in the <code>__early_ioremap</code>, we go through all early ioremap fixmap slots and search for the first free one in the <code>prev_map</code> array. When we found it we remember its number in the <code>slot</code> variable and set up size:</p>
<pre><code class="lang-C">slot = <span class="hljs-number">-1</span>;
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; FIX_BTMAPS_SLOTS; i++) {
    <span class="hljs-keyword">if</span> (!prev_map[i]) {
        slot = i;
        <span class="hljs-keyword">break</span>;
    }
}
...
...
...
prev_size[slot] = size;
last_addr = phys_addr + size - <span class="hljs-number">1</span>;
</code></pre>
<p>In the next spte we can see the following code:</p>
<pre><code class="lang-C">offset = phys_addr &amp; ~PAGE_MASK;
phys_addr &amp;= PAGE_MASK;
size = PAGE_ALIGN(last_addr + <span class="hljs-number">1</span>) - phys_addr;
</code></pre>
<p>Here we are using <code>PAGE_MASK</code> for clearing all bits in the <code>phys_addr</code> except the first 12 bits. <code>PAGE_MASK</code> macro is defined as:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PAGE_MASK       (~(PAGE_SIZE-1))</span>
</code></pre>
<p>We know that size of a page is 4096 bytes or <code>1000000000000</code> in binary. <code>PAGE_SIZE - 1</code> will be <code>111111111111</code>, but with <code>~</code>, we will get <code>000000000000</code>, but as we use <code>~PAGE_MASK</code> we will get <code>111111111111</code> again. On the second line we do the same but clear the first 12 bits and getting page-aligned size of the area on the third line. We getting aligned area and now we need to get the number of pages which are occupied by the new <code>ioremap</code> area and calculate the fix-mapped index from <code>fixed_addresses</code> in the next steps:</p>
<pre><code class="lang-C">nrpages = size &gt;&gt; PAGE_SHIFT;
idx = FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*slot;
</code></pre>
<p>Now we can fill <code>fix-mapped</code> area with the given physical addresses. On every iteration in the loop, we call the <code>__early_set_fixmap</code> function from the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/mm/ioremap.c" target="_blank">arch/x86/mm/ioremap.c</a>, increase the given physical address by the page size which is <code>4096</code> bytes and update the <code>addresses</code> index and the number of pages:</p>
<pre><code class="lang-C"><span class="hljs-keyword">while</span> (nrpages &gt; <span class="hljs-number">0</span>) {
    __early_set_fixmap(idx, phys_addr, prot);
    phys_addr += PAGE_SIZE;
    --idx;
    --nrpages;
}
</code></pre>
<p>The <code>__early_set_fixmap</code> function gets the page table entry (stored in the <code>bm_pte</code>, see above) for the given physical address with:</p>
<pre><code class="lang-C">pte = early_ioremap_pte(addr);
</code></pre>
<p>In the next step of <code>early_ioremap_pte</code> we check the given page flags with the <code>pgprot_val</code> macro and call <code>set_pte</code> or <code>pte_clear</code> depending on the flags given:</p>
<pre><code class="lang-C"><span class="hljs-keyword">if</span> (pgprot_val(flags))
        set_pte(pte, pfn_pte(phys &gt;&gt; PAGE_SHIFT, flags));
    <span class="hljs-keyword">else</span>
        pte_clear(&amp;init_mm, addr, pte);
</code></pre>
<p>As you can see above, we passed <code>FIXMAP_PAGE_IO</code> as flags to the <code>__early_ioremap</code>. <code>FIXMPA_PAGE_IO</code> expands to the:</p>
<pre><code class="lang-C">(__PAGE_KERNEL_EXEC | _PAGE_NX)
</code></pre>
<p>flags, so we call <code>set_pte</code> function to set the page table entry which works in the same manner as <code>set_pmd</code> but for PTEs (read above about it). As we have set all <code>PTEs</code> in the loop, we can now take a look at the call of the <code>__flush_tlb_one</code> function:</p>
<pre><code class="lang-C">__flush_tlb_one(addr);
</code></pre>
<p>This function is defined in <a href="https://github.com/torvalds/linux/blob/master" target="_blank">arch/x86/include/asm/tlbflush.h</a> and calls <code>__flush_tlb_single</code> or <code>__flush_tlb</code> depending on the value of <code>cpu_has_invlpg</code>:</p>
<pre><code class="lang-C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> __flush_tlb_one(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> addr)
{
        <span class="hljs-keyword">if</span> (cpu_has_invlpg)
                __flush_tlb_single(addr);
        <span class="hljs-keyword">else</span>
                __flush_tlb();
}
</code></pre>
<p>The <code>__flush_tlb_one</code> function invalidates the given address in the <a href="http://en.wikipedia.org/wiki/Translation_lookaside_buffer" target="_blank">TLB</a>. As you just saw we updated the paging structure, but <code>TLB</code> is not informed of the changes, that&apos;s why we need to do it manually. There are two ways to do it. The first is to update the <code>cr3</code> control register and the <code>__flush_tlb</code> function does this:</p>
<pre><code class="lang-C">native_write_cr3(native_read_cr3());
</code></pre>
<p>The second method is to use the <code>invlpg</code> instruction to invalidate the <code>TLB</code> entry. Let&apos;s look at the <code>__flush_tlb_one</code> implementation. As you can see, first of all the function checks <code>cpu_has_invlpg</code> which is defined as:</p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(CONFIG_X86_INVLPG) || defined(CONFIG_X86_64)</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> cpu_has_invlpg         1</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> cpu_has_invlpg         (boot_cpu_data.x86 &gt; 3)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
</code></pre>
<p>If a CPU supports the <code>invlpg</code> instruction, we call the <code>__flush_tlb_single</code> macro which expands to the call of <code>__native_flush_tlb_single</code>:</p>
<pre><code class="lang-C">static inline void __native_flush_tlb_single(unsigned long addr)
{
        asm volatile(&quot;invlpg (%0)&quot; ::&quot;r&quot; (addr) : &quot;memory&quot;);
}
</code></pre>
<p>or call <code>__flush_tlb</code> which just updates the <code>cr3</code> register as we have seen. After this step execution of the <code>__early_set_fixmap</code> function is finished and we can go back to the <code>__early_ioremap</code> implementation. When we have set up the fixmap area for the given address, we need to save the base virtual address of the I/O Re-mapped area in the <code>prev_map</code> using the <code>slot</code> index:</p>
<pre><code class="lang-C">prev_map[slot] = (<span class="hljs-keyword">void</span> __iomem *)(offset + slot_virt[slot]);
</code></pre>
<p>and return it.</p>
<p>The second function, <code>early_iounmap</code>, unmaps an <code>I/O</code> memory region. This function takes two parameters: base address and size of a <code>I/O</code> region and generally looks very similar to <code>early_ioremap</code>. It also goes through fixmap slots and looks for a slot with the given address. After that, it gets the index of the fixmap slot and calls <code>__late_clear_fixmap</code> or <code>__early_set_fixmap</code> depending on the <code>after_paging_init</code> value. It calls <code>__early_set_fixmap</code> with one difference to how <code>early_ioremap</code> does it: <code>early_iounmap</code> passes <code>zero</code> as physical address. And in the end it sets the address of the I/O memory region to <code>NULL</code>:</p>
<pre><code class="lang-C">prev_map[slot] = <span class="hljs-literal">NULL</span>;
</code></pre>
<p>That&apos;s all about <code>fixmaps</code> and <code>ioremap</code>. Of course this part does not cover all features of <code>ioremap</code>, only early ioremap but there is also normal ioremap. But we need to know more things before we study that in more detail.</p>
<p>So, this is the end!</p>
<h2 id="conclusion">Conclusion</h2>
<p>This is the end of the second part about linux kernel memory management. If you have questions or suggestions, ping me on twitter <a href="https://twitter.com/0xAX" target="_blank">0xAX</a>, drop me an <a href="anotherworldofworld@gmail.com">email</a> or just create an <a href="https://github.com/0xAX/linux-insides/issues/new" target="_blank">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me a PR to <a href="https://github.com/0xAX/linux-insides" target="_blank">linux-insides</a>.</strong></p>
<h2 id="links">Links</h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller" target="_blank">apic</a></li>
<li><a href="https://lwn.net/Articles/446528/" target="_blank">vsyscall</a></li>
<li><a href="http://en.wikipedia.org/wiki/Trusted_Execution_Technology" target="_blank">Intel Trusted Execution Technology</a></li>
<li><a href="http://en.wikipedia.org/wiki/Xen" target="_blank">Xen</a></li>
<li><a href="http://en.wikipedia.org/wiki/Real-time_clock" target="_blank">Real Time Clock</a></li>
<li><a href="http://en.wikipedia.org/wiki/E820" target="_blank">e820</a></li>
<li><a href="http://en.wikipedia.org/wiki/Memory_management_unit" target="_blank">Memory management unit</a></li>
<li><a href="http://en.wikipedia.org/wiki/Translation_lookaside_buffer" target="_blank">TLB</a></li>
<li><a href="http://0xax.gitbooks.io/linux-insides/content/Theory/Paging.html" target="_blank">Paging</a></li>
<li><a href="http://0xax.gitbooks.io/linux-insides/content/mm/linux-mm-1.html" target="_blank">Linux kernel memory management Part 1.</a></li>
</ul>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="linux-mm-1.html" class="navigation navigation-prev " aria-label="Previous page: Memblock">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="linux-mm-3.html" class="navigation navigation-next " aria-label="Next page: kmemcheck">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Fixmaps and ioremap","level":"1.8.2","depth":2,"next":{"title":"kmemcheck","level":"1.8.3","depth":2,"path":"mm/linux-mm-3.md","ref":"mm/linux-mm-3.md","articles":[]},"previous":{"title":"Memblock","level":"1.8.1","depth":2,"path":"mm/linux-mm-1.md","ref":"mm/linux-mm-1.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"mm/linux-mm-2.md","mtime":"2019-03-28T07:54:50.432Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2019-03-28T08:16:32.758Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

